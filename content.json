{"pages":[],"posts":[{"title":"使用hexo搭建自己的博客系统","text":"找工作的时候经常会看到这样一句话，“请附上博客、github 地址”。所以我下定决心要整一个博客玩玩。给自己加点料。自己写一个网站成本比较高，要去买服务器，买域名等等，太麻烦。在前辈的推荐下，学习了使用 hexo 搭建博客，感觉很方便。作为我个人微博的开幕首秀，就先写写 hexo 的上手使用吧。 首先先来看一下 hexo 官网的介绍 快速、简洁、高效。直击痛点，学起来。 一. 所需环境首先得安装 node、git，从官网上下载直接安装，一直下一步就好了，没啥可说的。 二. 安装 hexo命令行执行如下命令，全局安装 hexo，这样你就可以使用 hexo 命令了 1npm install hexo-cli -g 三. 初始化建站在一个空文件夹下执行下面的命令，完成建站。注意一定是空文件夹，不然会报错。 1hexo init 或者也可以执行下面的命令，folder 就是你的项目文件夹。 1hexo init &lt;folder&gt; 然后进入项目根目录，安装依赖的模块 1npm install 四. 参数配置配置项在项目根目录下的_config.yml 文件中，主要是对博客的基本信息等进行配置。配置信息很多,具体内容你可以看一下官网的说明，我只讲一下我用到的几点吧 主题配置你可以到官网下载你想要的主题，然后将下载好的文件解压后放到根目录的 themes 文件夹下，然后修改配置文件的 theme，就配置好主题了。 1theme: hexo-theme-Anisina-master 部署配置首先你得到你的 github 上新建一个仓库，项目名字为[yourName].github.io。yourName 是你的 github 名字。 注意项目名称一定要这样命名，不然就无法访问了。 然后配置文件里按照如下配置。repository 是你的仓库地址 1234deploy: type: git repository: https://github.com/123sky/123sky.github.io.git branch: master 然后你需要安装 hexo-deployer-git 1npm install hexo-deployer-git -S 图片配置写文章的时候不免需要引用图片，所以安装 hexo-asset-image，然后当你新建文章的时候，就会自动生成一个资源文件夹，把你的图片放到文件夹中，然后就可以的 md 文件中引用了。 首先确保你安装了 hexo-asset-image 依赖 1npm install hexo-asset-image -S 然后新建文章后，文件结构变成了如下 你会发现每个文章都会有一个资源文件夹。然后再你的文章中通过如下方式进行图片的引用 1![hexo官网截图](hexo.jpg) 五. 开始你的写作表演首先要创建文章,layout 表示你的文章布局，title 就是你的文章文件的名字（文章的名字是在文件中定义的。）。 1hexo new [layout] &lt;title&gt; 然后就可以在 source/_posts/的相应文件夹中找到刚刚创建的文件进行文章的编辑了。 六. 本地服务你可以先起一个本地服务来预览效果。确保安装了 hexo-server 依赖。 1npm install hexo-server --save 然后通过下面的命令启动服务，就可以进行预览了 123hexo server或hexo s 七. 发布部署预览发现没有问题之后就可以发布部署了，执行如下命令 1234hexo generatehexo deploy或hexo g -d 控制台提示成功之后，你就可以访问 123sky.github.io 来访问你的线上博客了。（123sky 是博主的 github 名字） 八. 主题文件修改从网上下载的主题有时候可能不满足我们的需求，我们也可以自己修改，但修改的时候一定要注意需要 hexo clean 一下，然后重新 hexo g -d，不然线上将不会生效。 九. 新建导航页面使用下面的命令创建导航页面,source 目录下面会增加一个叫 NAME 的文件夹，给里面的 index.md 文件中的 layout 增加一个布局，然后就可以在导航的布局文件中，通过 site.pages 获取相应的导航信息了。 1hexo new page \"NAME\" 十. 评论系统评论系统我选择的是“来必力”（来自韩国的），首先要注册账号，然后到管理页面-代码管理将代码粘贴到项目文件中。 结束开启博客之旅吧","link":"/2018/01/10/2018/01/使用hexo搭建自己的博客系统/"},{"title":"编码规范之eslint","text":"在团队协作中，为避免低级 Bug、产出风格统一的代码，会预先制定编码规范。使用 Lint 工具和代码风格检测工具，则可以辅助编码规范执行，有效控制代码质量。总之就是为了让别人看自己写的代码时，尽量不产生抵触情绪🙈。 首先了解一下基本知识。 eslint 结合 webpack 使用时，配置相关规则的文件在项目根目录的.eslintrc.js 文件中。 当然可以针对某种情况单独配置规则。例如下面的代码，规则默认是 new 一个对象必须赋值给一个变量，但是这里是一个特殊情况，需要特殊处理，所以通过注释的方式忽略掉。但是请不要乱用，通常还是要遵守统一规则的。 1234567/* eslint no-new: 0 */new Vue({ el: \"#app\", router, template: \"&lt;App/&gt;\", components: { App }}); 一些参数的含义 “off” 或 0 - 关闭规则“warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)“error”或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) 项目中使用标准配置，标准配置文档 下面就来看一下，我在 utry-vue-doc 中都遇到了哪些问题吧。 注：下面的设置为 0 的是我认为没必要的，设置为 2 的是我认为应该检查的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 箭头函数的参数使用圆括号'arrow-parens': 0,// production下不允许有debugger'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,// production下不允许有console'no-console': process.env.NODE_ENV === 'production' ? 2 : 0,// 禁用不必要的分号'no-extra-semi': 2,// (默认) 要求在语句末尾使用分号'semi': 0,// 强制分号前后有空格'semi-spacing': 0,// 函数圆括号之前有一个空格'space-before-function-paren': 0,// 语句块之前的空格'space-before-blocks': 2,// 强制在对象字面量的键和值之间使用一致的空格'key-spacing': 2,// 强制使用一致的反勾号、双引号或单引号'quotes': 0,// 强制将对象的属性放在不同的行上// 建议复杂的对象还是放在不同行上'object-property-newline': 0,// 强制使用一致的缩进,2个空格。switch语句缩进设置'indent': [2, 2, { \"SwitchCase\": 1 }],// 当最后一个元素或属性与闭括号 ] 或 } 在 不同的行时，// 允许（但不要求）使用拖尾逗号；// 当在 同一行时，禁止使用拖尾逗号。'comma-dangle': [2,'only-multiline'],// 强制关键字周围空格的一致性// 关键字前后都要有空格'keyword-spacing': 2,// 要求中缀操作符周围有空格'space-infix-ops': 2,// 强制在逗号周围使用空格// 逗号前边没空格，逗号后面使用一个或多个空格'comma-spacing': 2,// 禁止出现多个空格'no-multi-spaces': 2,// 禁止所有tab'no-tabs': 2,// 要求使用 === 和 !=='eqeqeq': 0,// 逗号风格// 要求逗号放在数组元素、对象属性或变量声明之后，且在同一行'comma-style': 2,// 禁用不必要的转义，什么叫不必要的转义这个还真不知道是啥意思'no-useless-escape': 0,// 块内填充（块语句以空行开始并且以空行结束）'padded-blocks': 0,// 禁止在对象字面量中出现重复的键'no-dupe-keys': 2,// 强制在花括号中使用一致的空格。// 左右花括号在同一行时，左花括号右边有一个空格,并且右花括号左边有一个空格。'object-curly-spacing': [2,'always'],// 要求使用骆驼拼写法'camelcase': 2,// ${variable} 应该在两个 (`)之间，不应该在两个(')或(\")之间'no-template-curly-in-string': 0,// 在注释有空白'spaced-comment': 2,// 禁用行尾空白'no-trailing-spaces': 0,// 大括号风格要求// 默认one true brace style。// 允许块的开括号和闭括号在 同一行'brace-style': [2, \"1tbs\", { \"allowSingleLine\": true }],// 禁止在返回语句中赋值'no-return-assign': 2,// 要求遵循大括号约定,即使代码块只有一条语句时，仍需要加大括号'curly': 2,// 禁用一成不变的循环条件'no-unmodified-loop-condition': 0,// 禁止或强制圆括号内的空格。(默认) 强制圆括号内没有空格'space-in-parens': 0,// new一个object必须赋值给一个变量'no-new': 2 大家如果有什么疑问也可以到eslint 官网查询。（搜索框里搜索一下，很多例子，一看就懂了）。 还想说一下编辑器一般都会有问题面板，如果有报问题，还是修改一下的比较好。编辑器也有自动整理代码格式的功能，一般是 ctrl+shift+f，会把代码结构整理下，但是有的时候也会有意想不到的结果，所以慎用吧。 不规范的代码往往是因为从其他地方粘贴过来导致的，所以粘贴之后还是整理一下比较好。 整理后的代码我新开了一个分支叫 sortOut，有需要的也可以看一下。 一些个人的观点，请大家多多指教吧，为了公司前端开发有一个更好的规范，为了少一些坑，哈哈哈哈。","link":"/2018/01/13/2018/01/编码规范之eslint/"},{"title":"迎宾机器人项目","text":"互联网大会结束有一段时间了，有幸成为公司机器人幕后工作者的一员。那个月里没少加班，临近末尾还通了几个宵，很辛苦，但是收获也挺多。最近闲下来了，就总结一下。 事件中心手动解除监听了解一下事件中心的具体实现。 12345678910111213141516// 首先在main.js中的data声明eventHubnew Vue({ el: \"#app\", router, template: \"&lt;App/&gt;\", components: { App }, data: { eventHub: new Vue() }});// 传播事件_this.$root.eventHub.$emit([eventName], [option]);// 接收事件_this.$root.eventHub.$on([eventName], [option]); 项目中遇到的一个坑，现象是这样的：接收 websocket 消息，然后通过事件中心的方式通知某组件中的轮播组件滚动到相应的位置，同时回调后台某一接口，但是每接收到 websocket，就会多增加一次回调后台的请求。原因是通过事件中心这种形式绑定的监听事件不会随着组件的销毁而取消绑定，需要手动的在组件销毁之前，移除事件的监听。 svg 使用项目中有一个展馆的平面图，需要每个展位都可以闪烁定位，因此使用了 svg。但是这张图其实是通过 ps 制作完成的。结合 snap.svg 的使用，完成了闪烁定位的功能。 12&lt;!-- 页面引入svg --&gt;&lt;object :data=\"getSvgDataUrl\" type=\"image/svg+xml\" id=\"mapSvg\"&gt;&lt;/object&gt; 1234567// load之后进行处理svgElement.addEventListener(\"load\", loadAfterFunction);// 添加闪烁动画snap(\"#alphasvg\") .select(\"#block\") .addClass(\"animated flash infinite\"); 需要注意的是，svg 中使用的 class 必须在 svg 文件中引入。 swiper 组件使用的一个坑设置了循环滚动时，swiper 实现方式是在 DOM 结构上，是使用的 clone 的方式，在首尾各添加一个 slide 单元。和任何的对象克隆一样，这会带来一些不可预支的问题。slide 中所有的代码克隆一次，这会导致问题产生。例如你 slide 中如果包含 id 的话，或者绑定 click 事件等。网上查了一些解决方法都是说使用 getElementsByClassName 绑定点击事件，但是仍然会产生问题。后来我发现 swiper 本身就可以绑定 click 事件，根据 event 对象，我们可以判断到点击的元素，来进行事件处理，完美解决。代码如下 12345678910111213141516171819202122swiperOption: { effect: \"slide\", autoplay: 8000, preventClicks: false, loop: true, grabCursor: true, setWrapperSize: true, pagination: '.swiper-pagination', paginationClickable: true, paginationBulletRender: function(swiper, index, className) { return '&lt;span class=\"' + className + '\"&gt;' + (index + 1) + '&lt;/span&gt;'; }, prevButton: '.swiper-button-prev', nextButton: '.swiper-button-next', observer: true, observeParents: true, onTouchStart: function(swiper, event) { if (event.target.className === 'moreToShowModal') { _this.openMoreModal() } }} vue 处理静态资源问题举例先说一下我遇到的两个问题： 问题一：如下代码，机器人 1 的图片无法显示，机器人 2 的图片正常显示。 12&lt;img :src=\"robot\" alt=\"机器人1\" /&gt;&lt;img :src=\"../assets/robot.jpg\" alt=\"机器人2\" /&gt; 12345data() { return { robot: '../assets/robot.jpg' }} 通过开发者工具查看，我们发现，机器人 2 的图片因为被编译成 base64 所以正常显示，而机器人 1 依然通过相对路径引用，然而因为 webpack 的编译，已经没有 assets 这个目录了，所以不会正常显示。static 目录不会被编译，因此我们可以将机器人 1 的图片放到 static 目录中，这样就可以正常显示了。 问题二：在根目录的 index.html 文件中引用 src 的 css 文件,build 之后样式未生效。 1&lt;link relhtml=\"stylesheet\" href=\"./src/style/reset.css\"&gt; 原因同样是因为 src 目录中的文件都经过编译了，所以通过相对路径找不到了。解决办法要么是从 static 目录中引用，要么是在 js 中通过 import 的方式引入。 其实上边问题的产生归根到底还是对 src/assets 和 static/ 这两个目录的理解不够深入，从网上找了资料，觉得下面这段还挺好的，原文来自hq5544.github.io webpack 如何处理静态资源首先要理解 webpack 如何处理静态资源。在 vue 组件中，所有的模版和 CSS 都是通过 vue-html-loader 和 css-loader 分析静态资源 URL。例如，在 &lt;img src=&quot;./logo.png&quot;&gt; 和 background: url(./logo.png)，&quot;./logo.png&quot; 是一个相对路径，会被 webpack 作为依赖模块处理。 因为 logo.png 不是 JavaScript，当作为一个依赖模块处理的时候，我们需要使用 url-loader 和 file-loader 来处理。这个模版已经为你配置好这些 loader，因此你可以直接使用例如文件名指纹和内嵌的 base64 代码等特性，在使用相对路径的某块的时候也不用担心部署问题。 因为 build 过程中，这些资源也许会被内嵌／复制／重命名，它们本质上是源代码的一部分。这就是为什么我们建议把要打包的静态资源放在 /src 中，和其它源代码并列。事实上，你甚至不用把全部静态资源放在 /src/assets，你也可以在模块／组件的基础上组织它们。例如，你可以为每一个组件自己建一个文件夹，让静态资源紧挨着它。 资源路径处理相对路径，例如，./assets/logo.png 将会被解析成依赖模块。它们将会被基于 webpack 输出配置所自动生成的 URL 所代替。 无前缀 URL，例如，assets/logo.png 将会被视为相对路径，并且变成 ./assets/logo.png。 带有 ~ 前缀的 URL 将会被视为依赖模块的请求，类似于 require('some-module/image.png')。如果你想要让 webpack 将它作为模块处理，可以使用这个前缀。例如，如果你想要用 assets 作为 alias，你需要使用 &lt;img src=&quot;~assets/logo.png&quot;&gt; 来确保 alias 可以使用。 相对跟目录的 URL，例如，/assets/logo.png 完全不会被 webpack 处理。 “真正的”静态资源相比之下，static/ 完全不会被 webpack 处理：它们会直接原样的复制到目标位置，也不更改文件名。你必须根据 config.js 文件中 build.assetsPublicPath 和 build.assetsSubDirectory，用绝对路径饮用这些文件。 假设一个带有如下默认配置的例子： 12345678// config.jsmodule.exports = { // ... build: { assetsPublicPath: \"/\", assetsSubDirectory: \"static\" }}; 存放在 static/ 中的文件应该用绝对路径 /static/[filename] 来引用。如果将 assetSubDirectory 的值改成 assets，那么这些 URL 将会变成 /assets/[filename]。 总结这次项目时间很紧张，并且需求也是一直变来变去。如果单纯为了赶需求，可能问成了当时的任务，但是新的需求来了你就需要去填之前为了赶需求时留下的坑。少给自己挖坑。","link":"/2018/01/16/2018/01/迎宾机器人项目/"},{"title":"2017年工作总结","text":"2017 年 9 月加入公司以来，将近五个月的时间里参加了很多项目，收获了很多知识。最大的收获应该是完成了我一个很早就有的想法——写个自己的博客。阮老师的一段话不能更赞同 “对我来说，博客首先是一种知识管理工具，其次才是传播工具。我的技术文章，主要用来整理我还不懂的知识。我只写那些我还没有完全掌握的东西，那些我精通的东西，往往没有动力写。炫耀从来不是我的动机，好奇才是。” 深有感触，所以决定写博客，总结，积累。 短短五个月经历了大大小小很多个项目，主要的包括了众包项目，组件开发，年会抽奖活动，互联网大会机器人前端，人马座（界面设计器）。要知道之前一年的时间都不会做这么多项目。这么多项目不能过去就过去了，每个项目结束都写过一篇博客总结过，这里就不详细说了，附上链接。 项目开发总结——机器人互联网大会vue 之 table 组件的开发项目开发总结——界面设计器 互联网大会项目感触颇多，由于时间紧，相关资料直到最后关口才拿到手，用户的想法也是一会儿一个，熬了几个通宵也算是完成任务了。任务是完成了，但是效率并不高，今后公司相关业务坑定少不了，不可能每个用户都安排这么多人力。人马座（界面设计器）就应运而生了。通过互联网大会的项目，我们总结经验，形成产品。 界面设计器，如何将共性部分抽取出来复用，特殊需求可以扩展这是摆在我们面前的问题。共性需求做成界面可配，特殊需求通过 iframe 嵌入是我们解决问题的思路。开发中发现的一点问题就是，没有一个明确的需求列表，设计和计划。也许是因为时间太赶，但还是希望能够将需求条目话，表明难点，紧急程度，然后简单进行设计，列个计划，这样开发起来思路更清晰，问题也能提早发现。开发过程中遇到的新需求新问题也都可以及时记录。 组件开发还是一个很锻炼人的事情，基于良好的设计，才能做到简洁易用，所以代码实现之前先进行了功能梳理，理清功能之间可能造成的影响，这样实际开发过程中也能更好的解决问题。 年会抽奖活动可能是一个很小的项目，之前的版本可能是很单纯的抽奖，这一次我加入了很多动画元素，整个系统更加活泼。 众包项目的开发过程中发现的问题是接口信息整理很简单，导致开发过程中很多不明确还要去沟通，如果接口信息详细会节省很多沟通成本。 总之这 5 个月的时间无论是从技术上，还是思想上都有了很大的提升。今年除了要完成公司的任务，也希望能够基于 vue 封装一套可复用的组建，并实际运用到项目当中。目标就是逐步向高级前端开发工程师靠拢。","link":"/2018/02/06/2018/02/2017年工作总结/"},{"title":"界面设计器开发总结","text":"对于项目开发过程中遇到的问题进行总结，主要是vue使用、css方面的总结。 vue 侦听器 watch深度监听,如果 data 是一个对象，他的属性发生了变化，但是newData === oldData，因为他们的指向是相同的 12345678watch: { data:{ handler: (newData,oldData) { }, deep: true }} 组件 v-modelv-model 其实是一个语法糖，这背后其实做了两个操作 v-bind 绑定一个 value 属性 v-on 指令给当前元素绑定 input 事件 12345678910111213141516171819202122232425262728// 父组件中&lt;my-component v-model=\"data\"&gt;&lt;/my-component&gt;//子组件中{ props：{ value: { type: Boolean, default: true } }, data() { return { status: this.value } }, watch:{ value:(newVal){ this.status = newVal } }, method: { changeStatus() { this.status = newStatus this.$emit('input', this.status) } }} 连续字母或数字不会自动换行新奇的发现如果 div 中存在连续字母或数字时，不会自动换行，即使固定了 div 的大小，也不会自动换行，并且超出 div 显示。 1234div { width: 200px; background: #ccc；;} word-wrap：break-word 使单词过长时,单词内自动换行。但是如果使用 flex 布局，此属性无效。 1234div { width: 200px; background: #ccc； word-wrap：break-word；;} word-break：break-all 使单词过长时，单词不会另起一行，只是在放不下才会另起一行。 1234div { width: 200px; background: #ccc； word-break：break-all；;} vuex 使用的深入理解项目中使用了 vuex，不知道大家有没有同样的疑问：vuex 和定义一个全局对象的区别是什么？比如我在 index.html 上定义一个变量名为 state 的全局对象{}，然后在里面初始化一些数据，这样全局也可以用啊，这和 vuex 定义有什么不一样？ 缺少时间旅行功能。vue-devtools 可以查看每个改变。 vuex 专做态管理，由一个统一的方法去修改数据，全部变量是可以任意修改的。 做日志搜集，埋点的时候，有 vuex 更方便。 全部变量多了会造成命名污染，vuex 不会，同时解决了父组件与孙组件，以及兄弟组件之间通信的问题。","link":"/2018/02/07/2018/02/界面设计器开发总结/"},{"title":"css深入学习之border","text":"css深入学习之border border-width 不支持百分比边框不会随着容器大小的变化而变化类似的还有 outline、box-shadow、text-shadow关键字 thin medium thick默认值为 3，因为 border-style：double 有效果至少要 3 像素 border-styledashed 虚线谷歌火狐实色区域宽高 3:1，实色和透明色 1:1。IE 实色宽高 2:1，实色透明色 2:1border-emate 解决此问题 dotted 点线谷歌火狐小方，ie 小圆 double 双线计算规则：双线宽度相等，中间区域+-1实例：实现三道杠的菜单按钮 See the Pen padding与布局2 by chenjp (@chenjp) on CodePen. inset 内凹 outset 外凸，山脊山谷很不常用 border-color colorborder-color 默认为 color 的颜色，border-shadow，text-shadow，outline 也是用途：hover 变色，只需要在父级上添加即可 See the Pen 加号按钮 by chenjp (@chenjp) on CodePen. background-position相对于左上角定位(css2.1)。实现右下角定位，因为 position 定位不包括 border，所以设置 position 的 x 为 100%，border 为固定值的宽度即可。 See the Pen 图片背景以右侧定位 by chenjp (@chenjp) on CodePen. border 之图形构建IE78 实现圆角三道杠三角实现模拟圆角，上下两个梯形 See the Pen border之三角形 by chenjp (@chenjp) on CodePen. 透明边框增加响应区域大小filter：drop-shadow 改变 png 图片颜色 布局使用border 等高布局，不支持百分比 See the Pen qoBWex by chenjp (@chenjp) on CodePen. 以上内容总结自张鑫旭老师在慕课网上的课程","link":"/2018/03/01/2018/03/css深入学习之border/"},{"title":"css深入学习之margin","text":"css深入学习之margin 与容器尺寸可视尺寸，占据尺寸 利用 margin 可以改变可视尺寸大小的特性改变水平方向的尺寸（容器大小没有设置固定值，普通 block 水平元素用途：一侧定宽，另一侧自适应。两端对其布局。 利用 margin 可以改变占据区域尺寸大小的特性滚动容器实现上下留白，padding 在火狐无效，所以用 margin 与百分比单位普通元素百分比计算规则，水平垂直方向的百分比值计算都是相对于父级宽度计算的。绝对定位元素则是相对于第一个定位祖先元素的宽度计算的 用途：宽高 2:1 的自适应矩形。 margin 重叠发生在 block 水平元素，只发生在垂直方向的（不考虑 writing-mode 改变文字书写方向） 三种情景： 相邻的兄弟 父级和第一个最后一个子元素margin-top 重叠条件父元素非块状格式化上下文父元素没有 border-top 设置父元素没有 padding-top 值父元素和第一个子元素没有行内元素分离margin-bottom 除了上边四个，还有没有 height 相关声明 空的 block 元素条件：没有 border 设置，没有 padding 值，里面没有行内元素，没有高度相关的设置 计算规则：正正取大值，正负相加，负负取最小值 原因：网页诞生之初，多是文章文字的展示，margin 重叠会使文字排版更好。 使用：表单等列表时，最好上下都设置 margin，这样新增删除某一项时，不会影响布局 margin auto宽度自动填充，如果设置了固定宽度，那么这一行就会产生剩余空间，margin auto 就是设置这一部分的。 auto 就是自动填充，设置 auto 就是剩余空间大小。 问题： 图片不水平居中，因为图片是行内元素。他没有剩余空间，解决办法就是把它设置为 block 块状元素。 垂直布局中，因为他高度不会自动填充，没有剩余空间。解决办法：设置 writing-mode 为垂直，但是水平就失效了。绝对定位，让它覆盖父级，然后设置大小，设置 margin auto 就行了。 负值定位两端对齐：横向列表，两端对齐。等高布局。两栏自适应布局。 dom 顺序应与视图顺序不符，这是不好的。 margin 无效 内敛元素（非替换元素，没有改变流方向）垂直方向 margin 无效。 margin 重叠 display 为 table-cell，table-row 等。替换元素除外。 火狐下 table-cell 类型表现与 inline-block 相同。IE 下 table-cell 表现正常。chrome 下 button 即使设置了 table-cell 都会被转换为 inline-block，其他的表现正常。 绝对定位元素非定位方向的 margin“无效”（看起来）。实际上是都有效的。 鞭长莫及。当有浮动元素时，margin 不会相对于浮动元素去 margin。 内敛特性，基线对齐，所以当 margin 再怎么小，也小不过基线（文字的下边线） 其他正常流 margin-start 相当于 margin-left，两者重叠，不累加。水平流从右向左时，相当于 margin-right垂直流下，相当于 margin-top 只有在 webkit 内核下有效。margin-before，margin-after，margin-collapse。 以上内容总结自张鑫旭老师在慕课网上的课程","link":"/2018/03/02/2018/03/css深入学习之margin/"},{"title":"css深入学习之padding","text":"css深入学习之padding padding与容器尺寸块状元素下padding 值暴走，一定会影响尺寸。width 为非 auto，padding 影响尺寸width 为 auto，或 box-sizing 为 border-box 时，padding 没有暴走，不影响尺寸。 内敛元素下垂直方向的 padding 不会影响尺寸，水平方向会。但是会影响背景色（占据空间） 用途：分割线的实现 See the Pen gvJoxd by chenjp (@chenjp) on CodePen. padding 取值不支持负值 百分比值相对于宽度计算用途：实现所有屏幕下都是正方形 See the Pen bLyaLy by chenjp (@chenjp) on CodePen. 内敛元素的 padding 同样相对于宽度计算，默认的高宽有细节差异，会换行。宽高差异是因为内敛元素的垂直 padding 会让‘幽灵空白节点’（内敛元素文本的 control-area 区域）显现，也就是规范中的 strut 出现。当 font-size 为零时，就好了。 标签元素的内置 paddingol/ulol/li 元素内置 padding-left，单位是 px 不是 em谷歌浏览器下是 40px字号很小时，左边间距很开字号很大时，序号跑到外边。一般文字不是很大时，padding-left 设置为 22 到 25 表单元素input/textarea 输入框内置 padding，大约为 1 到 2 像素button 元素内置 padding部分浏览器 select 下拉内置 padding，如火狐。IE8+可以设置 padding。radio/checkbox 无内置 padding 按钮的 padding 最难控制火狐浏览器下 padding 为 0 时，左右依然有 padding。设置 button::-moz-focus-inner{padding:0}即可解决。IE7 下，按钮文字越多，左右 padding 值越大，设置 overflow:visible 解决。padding 与高度计算不兼容。行高为 20，padding 为 10 时，IE7 高度为 45，IE8 和谷歌浏览器高度为 40，火狐为 42。利用 a 标签替换 button，或者借助 label。 图形绘制实现三道杠，白眼效果 See the Pen padding与图形绘制1 by chenjp (@chenjp) on CodePen. background-clip:content-box 实现背景色只在内容区域现实 布局实现百分比单位构建固定比例布局的结构，例如上面的所有屏幕一比一配合 margin 实现等高布局 See the Pen padding与布局1 by chenjp (@chenjp) on CodePen. 两栏自适应布局 See the Pen padding与布局2 by chenjp (@chenjp) on CodePen. 以上内容总结自张鑫旭老师在慕课网上的课程","link":"/2018/03/03/2018/03/css深入学习之padding/"},{"title":"css深入学习之z-index","text":"css深入学习之z-index 基础z-index 支持负值，支持长 css3 animation 动画，css2.1 时需要和定位元素配合使用。 与 css 定位属性没有嵌套：后来居上，谁大谁上。嵌套：祖先优先原则。 例子：祖先优先原则失效了？z-index 为 auto 时，当前层叠上下文的生成盒子层叠水平是 0，盒子（除非是根元素）不会创建一个新的层叠上下文。所以导致 block1 的 z-index 生效了。 See the Pen css深入学习之z-index by chenjp (@chenjp) on CodePen. 层叠上下文和层叠水平层叠上下文表示谁离皇帝更近，层叠水平决定谁离官员更近 层叠上下文三维概念，表示普通元素高人一等了。 存在页面根元素天生有层叠上下文。z-index 为数值的定位元素也有层叠上下文。设置其他属性，使得其存在。(包括设置了 flex，opacity 不为 1，tansform：roatate，filter 等) 特性可嵌套。每个层叠上下文和兄弟元素独立。每个层叠上下文都自成体系，元素内容被层叠之后，整个元素被认为是在父层的层叠顺序中。 层叠水平 层叠上下文中的每个元素都有一个层叠水平。 层叠水平就是普通元素的论资排辈 层叠水平和 z-index 不是一个东西 层叠顺序元素发生层叠时候有着特定的垂直显示顺序 七阶层叠水平 装饰： 层叠上下文的 background/border 负 z-index， 布局： block 块状水平盒子， float 浮动盒子， 内容： inline/inline-block 水平盒子， z-index:auto 或看成 z-index:0，不依赖 z-index 的层叠上下文（就是设置了除 z-index 以外的属性产生的层叠上下文） 正 z-index 意义：规范元素重叠时候的呈现规则为什么有七阶层叠水平符合页面加载和页面呈现。内容最重要。 例子：背景色是因为 inline-block 的层级更高，文字都是内联元素遵循后来居上。 See the Pen 七阶层叠水平1 by chenjp (@chenjp) on CodePen. z-index 与层叠上下文 定位元素默认 z-index：auto 可以看成 z-index：0 z-index 不为 auto 的定位元素会创建层叠上下文 z-index 层叠顺序的比较止步于父级层叠上下文 例子 1：为何定位元素会覆盖普通元素？因为定位元素未设置 z-index 时就是 auto，根据七阶层叠水平得到，其层级高于 inline-block 元素。 See the Pen z-index与层叠上下文1 by chenjp (@chenjp) on CodePen. 例子 2：block 的 z-index 为-1，找到他的第一个父级层叠上下文元素就是 wrap，根据七阶层叠水平 z-index 为负，但仍高于背景色，所以产生如下效果 See the Pen z-index与层叠上下文2 by chenjp (@chenjp) on CodePen. 例子 3：受制于父级层叠上下文 See the Pen z-index与层叠上下文3 by chenjp (@chenjp) on CodePen. z-index 与非定位元素层叠上下文 不支持 z-index 的层叠上下文元素的层叠顺序均是 z-index=auto 的级别 依赖 z-index 的层叠上下文，层叠顺序依赖 z-index 值。包括两种情况： position 为 relative/absolute 或者 fixed（但是 chrome 下，fixed 元素不需要设置 z-index 即可创建层叠上下文） display 为 flex/inline-flex 容器的子 flex 项 例子 1：除了第一个 div，其他的都创建了层叠上下文，z-index 都是 auto，遵循后来居上，所以产生如下效果 See the Pen z-index与非定位元素层叠上下文1 by chenjp (@chenjp) on CodePen. 例子 2：由于 block1 设置了 display：absolute，block2 设置了 flex，都创建了层叠上下文，层级相同，但背景色的七阶水平更低，所以在下边。 See the Pen z-index与非定位元素层叠上下文2 by chenjp (@chenjp) on CodePen. 例子 3：图片设置一个淡出的效果，文字在 div 完全显示后才显示。原因是 opacity 不是 1 时会创建层叠上下文，这是他的层级与文字的层级是一样的，相当于 z-index：auto，遵循后来居上，所以 div 遮住文字。当 opacity 为 1 时，div 变成普通元素，所以文字在 div 之上。 See the Pen z-index与非定位元素层叠上下文 3 by chenjp (@chenjp) on CodePen. z-index 使用忠告 最小化原则，能不用就别用 不随意设置，尽量不超过 2，使用后来居上覆盖 组件层级计数器，通过 js 设置 z-index。 通过设置 z-index 使元素可访问性隐藏 以上内容总结自张鑫旭老师在慕课网上的课程","link":"/2018/03/04/2018/03/css深入学习之z-index/"},{"title":"vue之slider组件的开发","text":"一个简单的滑块组件的开发，过程中也遇到了一些有趣的问题，这里总结一下 问题：如果组件默认是隐藏的，那么滑动范围的初始宽度就是零了。滑块的位置是通过设置 left 值来设定的，刚开始计算 left 值的思路是通过比例乘以滑动范围得到固定值，但是初始宽度是零了，所以初始滑块位置就产生了问题。 平时要获取一个元素的尺寸一般都会直接使用 offsetWidth 和 offsetHeight 来获取，但是这两个属性是通过 CSS 渲染到页面上时候才计算的。而 dispaly 属性为 none 的元素将不参与渲染，它不会在渲染环境中生成任何盒子，自然也无法从属性中获取到尺寸。 解决：left 值可以通过设置百分比值，不需要固定值，这样就不用滑动范围的宽度。 但是如果 100%时，滑块位置超过了滑动范围，这时通过设置 transform: translateX(-50%);，解决了问题。 滑动过程计算滑块位置还是需要用到滑动范围宽度，也不能直接用this.$refs.sliderBar.clientWidth，需要通过 computed 来获取 12345computed: { barWidth() { return this.$refs.sliderBar.clientWidth }}","link":"/2018/03/02/2018/03/vue之slider组件的开发/"},{"title":"express与koa","text":"express与koa2使用的简单对比 express1234567891011121314151617181920212223var express = require(\"express\");var app = express();var asyncIO = function(cb) { setTimeout(function() { cb(); }, 500);};var mid = function(req, res, next) { req.body = \"mark\"; next();};app.use(mid);app.use(function(req, res, next) { asyncIO(function() { req.body += \" saved\"; res.send(req.body + \" done\"); });});app.listen(3000); koa12345678910111213141516171819202122232425var koa = require(\"koa\");var app = koa();var asyncIO = function() { return new Promise(function(resolve) { setTimeout(function() { resolve(); }, 500); });};var mid = function() { return function*(next) { this.body += \" mark\"; yield next; this.body += \" done\"; };};app.use(mid());app.use(function*(next) { yield asyncIO(); this.body = \"saved\"; yield next;}); koa2 1234567891011121314151617181920var Koa = require(&apos;koa&apos;)var app = new Koa()var asyncIO = () =&gt; { return new Promise(rersolve =&gt; {settimeout(resolve,500)})}var mid = () =&gt; { async(next) =&gt; { this.body += &apos; mark&apos; await next this.body += &apos; done&apos; }}app.use(mid())app.use(async(next) =&gt; { await asyncIO() this.body = &apos;saved&apos; await next})","link":"/2018/05/10/2018/05/express与koa/"},{"title":"移动端开发总结","text":"1像素边框 适应不同dpi 文字小于12px时设置line-height无法居中 输入框无法自动获取焦点 1 像素边框1234567891011121314151617181920212223242526272829303132333435363738394041424344@mixin border-1px($part, $color: #ccc, $borderRadius: 0) { position: relative; &amp;::after { content: \" \"; width: 200%; height: 200%; position: absolute; top: 0; left: 0; z-index: 0; transform: scale(0.5, 0.5); transform-origin: top left; pointer-events: none; box-sizing: border-box; @if $part == top { border-top: 1px solid $color; /*no*/ } @if $part == right { border-right: 1px solid $color; /*no*/ } @if $part == bottom { border-bottom: 1px solid $color; /*no*/ } @if $part == left { border-left: 1px solid $color; /*no*/ } @if $part == x { border-left: 1px solid $color; /*no*/ border-right: 1px solid $color; /*no*/ } @if $part == y { border-top: 1px solid $color; /*no*/ border-bottom: 1px solid $color; /*no*/ } @if $part == all { border: 1px solid $color; /*no*/ border-radius: $borderRadius; } }}.border { @include border-1px(all);} 不同 dpi 下显示高清问题12345678910@mixin bg-image($url, $type: \"png\") { background-image: url($url+\".\"+$type); @media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) { background-image: url($url+\"@2x.\"+$type); }}.bg { @include bg-image(\"../assets/login-bg\", jpg);} 文字小于12，line-height无法垂直居中输入框无法自动获得焦点","link":"/2018/05/11/2018/05/移动端开发总结/"},{"title":"深入基础-性能优化篇","text":"缓存。http 缓存（强制缓存、协商缓存） 渲染。懒加载、懒执行 文件优化。 webpack. 安全问题。sql注入、XSS、CSRF 缓存彻底理解浏览器的缓存机制浅谈 Web 缓存 数据库缓存代理服务器缓存nginx 配置代理服务器缓存。 前后端未分离时，图片、js 文件等静态资源，通过 nginx 缓存，提高请求速度。 1234location ~ .*\\.(gif|jpg|png|css|js)(.*) { access_log off; expires 30d;} 前后端分离之后，不需要再配置缓存了 cdn 缓存http 缓存 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 强制缓存在缓存期间不需要请求，state code 为 200 Cache-Controlmax-age 会覆盖掉 Expires max-age s-maxage public private no-cache no-store Expires用来指定资源到期的时间，是服务器端的具体的时间点 协商缓存如果缓存有效会返回 304否则重新返回资源，状态码为 200 ETag / If-None-MatchLast-modified / If-Modified-SinceIf-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。 渲染懒加载图片懒加载： 判断图片是否在视口 图片出现在视口时，用 data-src 替换 src 监听滚动时节流处理 懒执行文件优化图片 css 代替图片 根据屏幕尺寸加载不同质量的图片 雪碧图 css 文件放 hedaer 中js 文件放在 body 结尾静态资源使用 cdn 加载webpack压缩代码拆分路由，按需加载常见 web 安全及防护原理sql 注入SQL 注入防御方法总结采用 sql 语句预编译和绑定变量防御;严格检查参数的数据类型。 1234String sql = \"select id, no from user where id=?\";PreparedStatement ps = conn.prepareStatement(sql);ps.setInt(1, id);ps.executeQuery(); Xss(cross-site scripting)跨站脚本攻击XSS 防御方法总结对 URL 中的参数，对用户输入提交给 web server 的内容，没有进行充分的过滤。对输入(和 URL 参数)进行过滤，对输出进行编码。 CSRF 跨站请求伪造Web 安全之 CSRF 攻击的防御措施Web 的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。尽量使用 POST，限制 GET;使用 Token（Anti CSRF Token）。 使用 Token 例子：用户访问某个表单页面。服务端生成一个 Token，放在用户的 Session 中，或者浏览器的 Cookie 中。在页面表单附带上 Token 参数。用户提交请求后， 服务端验证表单中的 Token 是否与用户 Session（或 Cookies）中的 Token 一致，一致为合法请求，不是则非法请求。","link":"/2019/07/17/2019/07/深入基础-性能篇/"},{"title":"深入基础-js篇-标准内置对象","text":"全局的对象（ global objects ）或称标准内置对象 值属性这些全局属性返回一个简单值，这些值没有自己的属性和方法。 InfinityNaNundefinednull 字面量globalThis 函数属性全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。 eval()uneval()isFinite()isNaN()parseFloat()parseInt()decodeURI()decodeURIComponent()encodeURI()encodeURIComponent()escape()unescape() 基本对象顾名思义，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。 ObjectFunctionBooleanSymbolErrorEvalErrorInternalErrorRangeErrorReferenceErrorSyntaxErrorTypeErrorURIError 数字和日期对象用来表示数字、日期和执行数学计算的对象。 NumberBigIntMathDate 字符串用来表示和操作字符串的对象。 StringRegExp 可索引的集合对象这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。 Array 使用键的集合对象这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 MapSetWeakMapWeakSet 结构化数据这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON （JavaScript Object Notation）编码的数据。 ArrayBufferSharedArrayBufferAtomicsDataViewJSON 控制抽象对象PromiseGeneratorGeneratorFunctionAsyncFunction 反射ReflectProxy 其他arguments","link":"/2019/09/15/2019/09/深入基础-js篇-全局/"},{"title":"深入基础-js篇-变量","text":"数据定义 数据类型 数据类型判断 数据类型转换 变量在内存中如何存储 变量提升。 数据定义 const、letlet 与 var 的区别： 重复声明：let 会报错 暂存死区：var 存在变量提升，而 let 编译时才初始化（let 声明的变量直到它们的定义被执行时才初始化） 块级作用域：let 只作用于其声明的块中 全局函数无法通过 this 使用 let 定义的全局变量。 12345let test = 1;function fn() { console.log(this.test);}fn(); // undefined 数据类型值类型：多个分店，独立经营。String、Number、Boolean、Undefined、Null、Symbol。 引用类型： 一家店，多个钥匙，共同经营。Object。 null 与 undefined 的区别 null 表示”没有对象”，即该处不应该有值。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 值类型比较的是值，引用类型比较是否是同一个引用 123var a = {};var b = {};a === b; // false,a与b指向两个对象 Symbol 的用途： 防止属性名称冲突 消除魔法字符串。 node 中摸块执行后得到的是同一个实例。 私有属性：reflect.ownKeys() 方法能够获取对象上所有键的列表，包括字符串和 symbol。通过 proxy 使得 Reflect.ownKeys()无法获取 symbol，从而创建了对象的私有属性。 Object.getOwnPropertySymbols 获取对象的 symbol 属性 symbol 在以下情况下会被忽略： for…in 迭代中不可枚举。 JSON.strIngify()时以 symbol 值作为键的属性会被完全忽略。 12345678910111213141516171819202122232425262728293031323334353637let proxy;{ const favBook = Symbol(\"fav book\"); const obj = { name: \"Thomas Hunter II\", age: 32, _favColor: \"blue\", [favBook]: \"Metro 2033\", [Symbol(\"visible\")]: \"foo\" }; const handler = { ownKeys: target =&gt; { const reportedKeys = []; const actualKeys = Reflect.ownKeys(target); for (const key of actualKeys) { if (key === favBook || key === \"_favColor\") { continue; } reportedKeys.push(key); } return reportedKeys; } }; proxy = new Proxy(obj, handler);}console.log(Object.keys(proxy)); // [ 'name', 'age' ]console.log(Reflect.ownKeys(proxy)); // [ 'name', 'age', Symbol(visible) ]console.log(Object.getOwnPropertyNames(proxy)); // [ 'name', 'age' ]console.log(Object.getOwnPropertySymbols(proxy)); // [Symbol(visible)]console.log(proxy._favColor); // 'blue' 数据类型判断typeof undefined、boolean、number、string、symbol。返回基本类型，null，function 除外。 typeof null // object （使用 New 操作符）除 Function 外的所有构造函数的类型都是 ‘object’ instanceof判断一个实例是否属于某个构造函数。测试构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。 1234567891011121314function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ }} constructor不稳定，constructor 容易被修改。无法识别 null、undefined 1new Number().constructor === Number; toString1Object.prototype.toString.call(1) === \"[object Number]\"; 类型转换转换规则toNumber 输入类型 结果 undefined NaN null 0 boolean 0 或 1 object valueOf()、toString()、NaN string number 不变 toString 输入类型 结果 undefined ‘’ null ‘’ boolean ‘true’或’false’ object valueOf()、toString()、’[object Object]’ string 不变 number 按进制转换 隐式转换 加号运算符 == 变量在内存中如何存储js 对象数据结构底层实现原理 123var a = {};var b = {};a === b; // false,a与b指向两个对象 变量提升第一段代码存在变量提升，第二段代码存在函数提升 1234567891011var foo = function() { console.log(\"foo1\");};foo(); // foo1var foo = function() { console.log(\"foo2\");};foo(); // foo2 1234567891011function foo() { console.log(\"foo1\");}foo(); // foo1function foo() { console.log(\"foo2\");}foo(); // foo2","link":"/2019/09/15/2019/09/深入基础-js篇-变量/"},{"title":"深入基础-js篇-执行机制","text":"事件循环，包括同步任务和异步任务。异步任务又包括宏任务和微任务。 大数据量渲染采用requestAnimationFrame。 异步循环分为并行与串行。 EventLoop带你彻底弄懂 Event Loop微任务、宏任务与 Event-Loop js 是单线程的。多线程会存在一个删除 Dom 节点，一个新增 Dom 节点该听谁的的问题。 执行全局 Script 同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如 setTimeout 等）； 全局 Script 代码执行完毕后，调用栈 Stack 会清空； 从微队列 microtask queue 中取出位于队首的回调任务，放入调用栈 Stack 中执行，执行完后 microtask queue 长度减 1； 继续取出位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到直到把 microtask queue 中的所有任务都执行完毕。注意，如果在执行 microtask 的过程中，又产生了 microtask，那么会加入到队列的末尾，也会在这个周期被调用执行； microtask queue 中的所有任务都执行完毕，此时 microtask queue 为空队列，调用栈 Stack 也为空； 取出宏队列 macrotask queue 中位于队首的任务，放入 Stack 中执行； 执行完毕后，调用栈 Stack 为空； 重复第 3-7 个步骤； 宏队列 macrotask 一次只从队列中取一个任务执行，执行完后就去执行微任务队列中的任务；微任务队列中所有的任务都会被依次取出来执行，知道 microtask queue 为空； 12345678910111213141516171819202122232425262728293031console.log(1);setTimeout(() =&gt; { console.log(2); Promise.resolve().then(() =&gt; { console.log(3) });});new Promise((resolve, reject) =&gt; { console.log(4) resolve(5)}).then((data) =&gt; { console.log(data); Promise.resolve().then(() =&gt; { console.log(6) }).then(() =&gt; { console.log(7) setTimeout(() =&gt; { console.log(8) }, 0); });})setTimeout(() =&gt; { console.log(9);})console.log(10); 1234567891011121314151617181920async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");}async function async2() { console.log(\"async2\");}console.log(\"script start\");setTimeout(function() { console.log(\"setTimeout\");}, 0);async1();new Promise(function(resolve) { console.log(\"promise1\"); resolve();}).then(function() { console.log(\"promise2\");});console.log(\"script end\"); 同步任务主线程上排队，一个任务执行完成之后才能执行下一个任务。 异步任务存放于任务队列(消息队列)，当异步任务可执行时加入主线程执行。 IO 事件、用户事件（点击、滚动）等指定了回调函数，这些事件触发之后就会加入到任务队列，等待主线程读取。 宏队列（macrotask、tasks）一些异步任务的回调会依次进入 macro task queue，等待后续被调用，这些异步任务包括： setTimeoutsetIntervalsetImmediate (Node 独有)I/OUI rendering (浏览器独有) 微队列（microtask、jobs）另一些异步任务的回调会依次进入 micro task queue，等待后续被调用，这些异步任务包括： process.nextTick (Node 独有)PromiseObject.observeMutationObserver 大数据量渲染setInterval是不可靠的由于 JavaScript 是单线程的，所以定时器的实现是在当前任务队列完成后再执行定时器的回调的，假如当前队列任务执行时间大于定时器设置的延迟时间，那么定时器就不是那么可靠了。 理论上动画保持在平均每秒刷新 60 次的情况下就是流畅的。但 setInterval 无法保证。 requestAnimationFrame浏览器在下次重绘之前调用指定的回调函数更新动画。既不是宏任务也不是微任务。 当requestAnimationFrame() 运行在后台标签页或者隐藏的&lt;iframe&gt;里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。 CSS3 transition或animation动画也是走的跟你一样的绘制原理。（CSS3动画在Tab切换回来的时候，动画表现并不暂停；Tab切换之后，计算渲染绘制都停止，Tab切换回来时似乎通过内置JS计算了动画位置实现重绘，造成动画不暂停的感觉）。 循环异步All in （并行）1await Promise.call(times.map(time =&gt; sleep(time))); One by one （串行）消耗时间场，资源占用小 123for (let time of times) { await sleep(time);}","link":"/2019/09/15/2019/09/深入基础-js篇-执行机制/"},{"title":"深入基础-js篇-柯里化 currying","text":"比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。 部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 JavaScript 柯里化 柯里化实现123456789function currying(fn, ...args) { if (args.length &gt;= fn.length) { return fn(...args); } else { return function(args2) { return currying(fn, ...args, ...args2); }; }} 1234567891011121314151617181920function currying(fn, isEnd = false, ...args) { if (isEnd) { return fn(...args); } else { return function(...args2) { return currying(fn, args2.length === 0, ...args, ...args2); }; }}function add(...args) { return args.reduce((acc, cur) =&gt; { return acc + cur; }, 0);}var sum = currying(add);sum(1)();sum(1)(2)(3)(4)();sum(1)(2)(3)(4)(5)(6)(); 作用预加载、参数复用1234567891011match(/\\s+/g, \"hello world\");// [ ' ' ]match(/\\s+/g)(\"hello world\");// [ ' ' ]var hasSpaces = match(/\\s+/g);// function(x) { return x.match(/\\s+/g) }hasSpaces(\"hello world\");hasSpaces(\"hi world\"); 提前返回1234567891011var addEvent = function(el, type, fn, capture) { if (window.addEventListener) { el.addEventListener(type, function(e) { fn.call(el, e); }, capture); } else if (window.attachEvent) { el.attachEvent(\"on\" + type, function(e) { fn.call(el, e); }); }}; 延迟执行1234567&lt;div data-name=\"name\" onClick=\"handleOnClick\" /&gt;&lt;div onClick=\"handleOnClick.bind(null, data)\" /&gt;&lt;div onClick=\"() =&gt; handleOnClick(data)\" /&gt;&lt;div onClick=\"currying(handleOnClick, data)\" /&gt;","link":"/2019/09/15/2019/09/深入基础-js篇-柯里化/"},{"title":"深入基础-js篇","text":"数组。遍历方法、操作数组的方法。 深浅拷贝。 正则表达式。 好文推荐javascript 深入系列 数组遍历 for for-in应用于数组：循环返回的是数组的下标和数组的属性和原型上的方法和属性应用于对象：循环返回的是对象的属性名和原型中的方法和属性。 for-of使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。 forEach map filter every some reduce 操作数组 shift 删除第一个元素，并返回该元素的值 深浅拷贝浅拷贝… assign 深拷贝JSON.parse(JSON.stringify(object))会忽略 undefined会忽略 symbol会忽略 函数不能解决循环引用的对象 proxyreflect 明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上 让 Object 操作都变成函数行为 不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为 修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。 正则表达式元字符 元字符 作用 . 匹配任意字符除了换行符和回车符 [] 匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字 ^ ^9，这样使用代表匹配以 9 开头。[^9]，这样使用代表不匹配方括号内除了 9 的字符 {1, 2} 匹配 1 到 2 位字符 (yck) 只匹配和 yck 相同字符串 | 匹配 | 前后任意字符 \\ 转义 * 只匹配出现 0 次及以上 * 前的字符 + 只匹配出现 1 次及以上 + 前的字符 ? ? 之前字符可选 修饰语 修饰语 作用 i 忽略大小写 g 全局搜索 m 多行 字符简写 简写 作用 \\w 匹配字母数字或下划线 \\W 和上面相反 \\s 匹配任意的空白符 \\S 和上面相反 \\d 匹配数字 \\D 和上面相反 \\b 匹配单词的开始或结束 \\B 和上面相反","link":"/2019/09/15/2019/09/深入基础-js篇/"},{"title":"界面设计器开发思路","text":"","link":"/2019/10/10/2019/10/界面设计器开发思路/"},{"title":"vue之table组件的开发","text":"开发一套 vue 的 table 组件，通过零零散散的时间算是基本上写完了。今天就来总结一下吧。 设计文档为了开发过程中有一个参照，所以简单的写了一个计划。 一个大而全的表格组件即将在我手中诞生了，想想就有点小激动。给领导看过之后说了一句话，让我受益匪浅，赶紧记录一下，大意就是“并不是大而全就好用，重要的是要让别人觉得好用，可以用。” 反思总结了一下，重新整理计划，发现先前设计的搜索区域和工具区域其实很难控制好，因为不同的项目界面设计上差别很大，因此去除了这两部分。还有之前是想传 url 给组件，然后组件内部去请求后台数据，这样组也很难控制，还是传递数据给组件这样比较好。 设计好了就开工吧 开发要点、难点 为完成表头表体分离的功能，表头和表体需要两个 table，这就需要维护每个表头和相应表体的对齐关系。 如果表体滚动时会产生滚动条，所以表头需要留出相应大小的位置。 为了完成列固定的功能，同样需要 table，又要维护对齐关系了，同时还要同步滚动。 表头分组功能数据处理。 行合并，列合并的功能。 异步请求导致出错。 数据准备用户将表头信息 columns、表格数据 data、参数信息 options 传给组件。 表头数据示例内容如下：title 显示的文字；type 表示这一列的类型，包括 selection（选择）、detail（详情）；key 对应数据，用于获取数据；width 设置当前列的宽度；aligin 内容对齐方式；fixed 固定列位置；sortable 是否可以排序；children 表示分组；render 渲染的内容，可以自定义处理内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109columns: [ { type: \"selection\", key: \"selection\", width: 60, align: \"center\", fixed: \"left\" }, { title: \"姓名\", key: \"name\", sortable: true }, { title: \"其他\", fixed: \"left\", children: [ { title: \"年龄\", key: \"age\", sortable: (a, b, isAsc) =&gt; { if (isAsc) { return a - b; } else { return b - a; } } }, { title: \"地址\", key: \"address\", children: [ { title: \"街道\", key: \"street\" }, { title: \"街区\", key: \"block\", children: [ { title: \"楼栋\", key: \"building\" }, { title: \"门牌号\", key: \"number\" } ] } ] } ] }, { title: \"公司\", key: \"company\", children: [ { title: \"公司地址\", key: \"companyAddress\" }, { title: \"公司名称\", key: \"companyName\" } ] }, { title: \"性别\", key: \"gender\" }, { title: \"操作\", key: \"render\", type: \"render\", fixed: \"right\", width: 210, render: (h, params) =&gt; { return [ h( \"Button\", { props: { type: \"primary\", size: \"small\" }, on: { click: function() { console.log(\"你点击了删除按钮\"); } } }, \"删除\" ), h( \"Button\", { props: { type: \"primary\", size: \"small\" } }, \"修改\" ) ]; } }]; options 参数的配置形式如下，height 表示表格的高度，minWidth 表示表格最小宽度，currentPage 当前页码，total 总条目数，pageSize 当前页大小，headBackground 表头背景色，stripe 斑马线颜色，bodyHover 悬浮颜色,rowRender 表体渲染函数，bodyEndRender 表格结尾 123456789101112options: { height: 263, minWidth: 1500, currentPage: 1, total: 10, pageSize: 10, headBackground: '#f5f7fa', stripe: '#fafafa', bodyHover: '#f5f7fa', rowRender: (h, params) =&gt; { }, bodyEndRender: (h, params) =&gt; { }} data 是数据，以一个对象数组的形式传入即可。 关键点举例分析下面就几个关键点的代码进行解析 表头和相应表体的对齐关系利用 colgroup 统一表头和表体每一列的宽度，如果有设置具体宽度那么使用设置的宽度，如果没有设置宽度，那么以表体每一列的宽度我基准进行设置。但要注意如果给表体设置了固定的高度，当产生滚动条时，表头也要预留出滚动条的宽度。具体代码如下 12345678&lt;colgroup&gt; &lt;col v-for=\"(item, index) in cloneColumns\" :key=\"index\" :width=\"item.width?item.width:item.newWidth\" /&gt; &lt;col v-if=\"scrollBarWidth\" :width=\"scrollBarWidth\" /&gt;&lt;/colgroup&gt; 123456789const $td = this.$refs.tableBodyEl.$el .querySelectorAll(\"tbody tr\")[0] .querySelectorAll(\"td\");for (let i = 0; i &lt; $td.length; i++) { let width = parseInt(getStyle($td[i], \"width\")); if (!this.cloneColumns[i].width) { Vue.set(this.cloneColumns[i], \"newWidth\", width); }} 同步滚动业务需求是这样的，出现横向滚动条时某些列需要固定。实现效果如下 遇到的问题主要是因为，三个表格在滚动时，滚动其中一个时另外两个需要同时随着滚动，但由于设置 scrollTop 时同样会触发 onScroll 事件，导致滚动时的卡顿。解决方案是在 mouseenter 里面绑定 scroll 事件，这样卡顿的问题就解决了。代码很简单，就不放了。 表头分组表格分组时计算 colspan rowspan 是一个难点。需求是要解析上面提到的 columns 数据，然后生成如下的表头 解决的思路是递归的方式，让父辈的 colspan 是子辈的和。深层遍历时记录深度，最上层的 level 就是 1，每深入一层，level 加 1。这样有子辈的 rowspan 就是 1，没有子辈的就填满空白就可以了。具体代码的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 表格分组时计算colspan rowspanconst convertToRows = (originColumns, tag) =&gt; { //表头colspan设置 const traverse = (column, parent) =&gt; { if (parent) { column.level = parent.level + 1; if (this.maxLevel &lt; column.level) { this.maxLevel = column.level; } } if (column.children) { let colSpan = 0; column.children.forEach(subColumn =&gt; { traverse(subColumn, column); colSpan += subColumn.colSpan; }); column.colSpan = colSpan; } else { column.colSpan = 1; } }; originColumns.forEach(column =&gt; { column.level = 1; traverse(column); }); const rows = []; for (let i = 0; i &lt; this.maxLevel; i++) { rows.push([]); } const allColumns = getAllColumns(originColumns); allColumns.forEach((column, index) =&gt; { column._index = index; // 表头rowspan设置 if (!column.children) { column.rowSpan = this.maxLevel - column.level + 1; } else { column.rowSpan = 1; } // 设置表体要显示的内容的key if (tag === \"center\" &amp;&amp; column.colSpan === 1) { this.cloneColumns.push(column); } rows[column.level - 1].push(column); }); return rows;}; 复杂业务需求变态需求年年有，想做一个“万精油”一样的组件很难。先看一个这样的需求，实现效果如图所示。 这其实也是最近一个版本的需求，这个版本之前不知道改了多少版。这种定制化要求极高的就纯手工来吧，上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283options5: { rowRender: (h, params) =&gt; { let _this = this; let renderHtml = []; for (var i = 0; i &lt; params.rows.length; i++) { let tempRender = []; let row = params.rows[i]; let rowStyle = i % 2 === 0 ? \"background-color:#eef7fc\" : false; for (var j = 0; j &lt; params.columns.length; j++) { let column = params.columns[j]; let temp = null; switch (column.key) { case \"acceptanceTime\": temp = formatDate(new Date(row[column.key]), \"YYYY-MM-dd hh:mm:ss\"); tempRender.push( h(\"td\", { attrs: { style: rowStyle } }, [ h(\"div\", { attrs: { class: \"table-cell\" } }, temp) ]) ); break; case \"ownerPhone\": temp = row.ownerPhone + \";\" + row.callinUser; tempRender.push( h(\"td\", { attrs: { style: rowStyle } }, [ h(\"div\", { attrs: { class: \"table-cell\" } }, temp) ]) ); break; case \"voice\": tempRender.push( h(\"td\", { attrs: { style: rowStyle } }, [ h( \"div\", { attrs: { class: \"table-cell\", style: \"cursor: pointer\" }, on: { click: (function(i) { return function() { _this.playVoice((i % 4) + 1); }; })(i) } }, [h(\"button\", {}, \"播放音频\")] ) ]) ); break; default: temp = row[column.key]; tempRender.push( h(\"td\", { attrs: { style: rowStyle } }, [ h(\"div\", { attrs: { class: \"table-cell\" } }, temp) ]) ); break; } } renderHtml.push(h(\"tr\", tempRender)); let tempHtml = [ h(\"td\", { attrs: { colSpan: 4, style: rowStyle } }, [ h(\"div\", { attrs: { class: \"table-cell\" } }, [ h(\"span\", { attrs: { style: \"font-weight: bold\" } }, \"移车地址：\"), row.movingPosition ]) ]) ]; tempHtml.push( h(\"td\", { attrs: { colSpan: 4, style: rowStyle } }, [ h(\"div\", { attrs: { class: \"table-cell\" } }, [ h(\"span\", { attrs: { style: \"font-weight: bold\" } }, \"备注：\"), row.remark ]) ]) ); renderHtml.push(h(\"tr\", tempHtml)); } return renderHtml; };} 这里遇到了一个闭包的问题，播报语音时需要四种类型的语音循环匹配。循环中用到的 i 是同一个变量，所以导致最终都是播放的同一个语音。后来加了一个立即执行函数，解决了问题。后来发现其实声明 i 的时候用 let 就可以了，更简单。 总结第一次做组件开发，收获还是挺多的，包括对迭代，闭包等知识有了进一步的了解。结束。","link":"/2018/01/15/2018/01/vue之table组件的开发/"},{"title":"前端开发规范","text":"为了避免低级 Bug，为了代码赏心悦目，为了少挖坑。 HTML 篇 空元素标签都不加 “/” 字符。 空元素包括 area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr。 12&lt;br /&gt;&lt;img src=\"./img/bg.jpg\" alt=\"背景图片\" /&gt; 标签名、类名、标签属性用短横线。变量值采用驼峰。 12345&lt;city-list class=\"item-style\" data-name=\"name\" :class=\"activeClass\"&gt;&lt;/city-list&gt; 不需要为 CSS、JS 指定类型属性。 12&lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;link href=\"./index.css\" rel=\"stylesheet\"&gt;&lt;/link&gt; 元素属性值使用双引号语法。 1&lt;input type=\"radio\" name=\"name\" checked=\"checked\" :class=\"'active'+index\" /&gt; 特殊字符引用。 1&lt;a href=\"#\"&gt;more&amp;gt;&amp;gt;&lt;/a&gt; 统一采用两格空格的方式缩进。 123&lt;div class=\"jdc\"&gt; &lt;a href=\"#\"&gt;&lt;/a&gt;&lt;/div&gt; 每个块状元素独立一行，内联元素可选。 12345&lt;div&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 段落元素与标题元素只能嵌套内联元素。 不要在 p 标签中还出现 div 这种情况。 尽量减少深层嵌套。 能用一个 div 包裹，就不要再多用一个包裹了。 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。 12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 代码模块与模块之间可以通过增加空行的形式分隔开。 CSS 篇 统一使用展开格式书写样式。 1234.jdc { display: block; width: 50px;} 不使用 ID 选择器。 统一使用两格缩进。由于多数项目采用了 less，建议每一个模块用一个总的 class 包裹。 123456789101112131415161718192021.main { .header { .title { } .logo { } } .left-menu { .list { } .active { } } .content { } .footer { }} 空格 左括号与类名之间一个空格，冒号与属性值之间一个空格。逗号分隔的取值，逗号之后一个空格。这些都可以通过编辑器的代码格式整理功能实现。 为单个 css 选择器或新申明开启新行 12345678.jdc,.jdc_logo,.jdc_hd { color: #ff0;}.nav { color: #fff;} 取值不要带有不必要的 0。不要为 0 指明单位。 12color: rgba(255, 255, 255, 0.5);margin: 0 10px; 顺序。 布局定位属性：display / position / float / clear / visibility / overflow 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif; color: #333; background: rgba(0, 0, 0, 0.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;} 样式重置 移动端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* { -webkit-tap-highlight-color: transparent; outline: 0; margin: 0; padding: 0; vertical-align: baseline;}body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td { margin: 0; padding: 0; vertical-align: baseline;}img { border: 0 none; vertical-align: top;}i,em { font-style: normal;}ol,ul { list-style: none;}input,select,button,h1,h2,h3,h4,h5,h6 { font-size: 100%; font-family: inherit;}table { border-collapse: collapse; border-spacing: 0;}a { text-decoration: none; color: #666;}body { margin: 0 auto; min-width: 320px; max-width: 640px; height: 100%; font-size: 14px; fon-family: -apple-system, Helvetica, sans-serif; line-height: 1.5; color: #666; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important;}input[type=\"text\"],textarea { -webkit-appearance: none; -moz-appearance: none; appearance: none;} PC 端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119html,body,div,h1,h2,h3,h4,h5,h6,p,dl,dt,dd,ol,ul,li,fieldset,form,label,input,legend,table,caption,tbody,tfoot,thead,tr,th,td,textarea,article,aside,audio,canvas,figure,footer,header,mark,menu,nav,section,time,video { margin: 0; padding: 0;}h1,h2,h3,h4,h5,h6 { font-size: 100%; font-weight: normal;}article,aside,dialog,figure,footer,header,hgroup,nav,section,blockquote { display: block;}ul,ol { list-style: none;}img { border: 0 none; vertical-align: top;}blockquote,q { quotes: none;}blockquote:before,blockquote:after,q:before,q:after { content: none;}table { border-collapse: collapse; border-spacing: 0;}strong,em,i { font-style: normal; font-weight: normal;}ins { text-decoration: underline;}del { text-decoration: line-through;}mark { background: none;}input::-ms-clear { display: none !important;}body { font: 12px/1.5 \\5fae\\8f6f\\96c5\\9ed1, \\5b8b\\4f53, \"Hiragino Sans GB\", STHeiti, \"WenQuanYi Micro Hei\", \"Droid Sans Fallback\", SimSun, sans-serif; background: #fff;}a { text-decoration: none; color: #333;}a:hover { text-decoration: underline;} JS 篇 对象 使用对象方法的简写方式。 12345678const item = { job, department, value: 1, addValue(val) { return item.value + val; }}; 大括号 统一判断语句大括号风格。仅有一条执行语句时也要加大括号。 12345if (foo) { bar();} else { baz();} 空格 在单行代码块中使用空格。 123456function foo() { return true;}if (foo) { bar = 0;} 逗号后面使用空格，逗号前面不加空格。 123456789101112var foo = 1, bar = 2;var list = [ { id: 1, name: \"张三\" }, { id: 2, name: \"李四\" }]; 对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格 1var obj = { foo: \"haha\" }; 代码块、函数括号前后都要加空格。函数使用时不要空格 123456789if (a) { b();}function func(x) { // ...}func(); 操作符前后都需要添加空格。 12var sum = 1 + 2;var temp = isTrue ? \"goog\" : \"bad\"; 字符串 字符串统一使用单引号的形式 ‘’。 12const temp = \"hello world\";const describe = '&lt;div class=\"active\"&gt;&lt;/div&gt;'; 注释 单行注释。独立一行，不要写在代码后边。 12345678910// 学生人数let studentNum = 100;// 参数列表let options = { // 当前是第几页 pageNum: 1, // 页大小 pageSize: 10}; 多行注释。只有一行时不要用多行注释。尽量使用单行注释。 1234/** * 这里是多行注释 * 这里是多行注释 */ 文件注释。 1234567/** * @Author: chenjp * @Date: 2017-12-22 16:10:36 * @Last Modified by: chenjp * @Last Modified time: 2017-12-22 16:12:20 * @describe: 首页模板 */ 方法注释 123456789/** * 函数描述 * * @param {string} p1 参数1的说明 * @param {string} p2 参数2的说明，比较长 * 那就换行了. * @param {number=} p3 参数3的说明（可选） * @return {Object} 返回值描述 */ 命名 驼峰式命名。变量名用名词。方法名动词在前名词在后。构造函数首字母大写。 注意事项 强制两个缩进。 强制不使用分号。 合理使用 const、let、var。 使用行尾逗号。禁止拖尾逗号。 空白行分离代码逻辑。 禁止使用链式赋值。 减少 dom 操作。 catch 进行统一处理。 避免直接操作 prototype。 不要使用 eval()、with() {}。 不要修改内置对象，如 Object 和 Array。 再啰嗦几句 JPEG 图的时候，质量一般控制在 60。 图片大小一般控制在 200KB 以内。 减少请求数，使用雪碧图，字体图标等。 文件、文件夹命名统一小写。 自己的文件不要提交。例如编辑器配置文件不要提交。 代码中没有 debugger 断点。大篇幅的日志。 控制台没有报错。 不存在样式问题。 是否遵守设计稿的要求。包括间距，大小，颜色等等。 兼容性考虑，是否兼容要求的浏览器版本。 关于项目结构建议如下图。文件很多时请使用文件夹区分类别。 附录注释的数据类型种类","link":"/2018/01/13/2018/01/前端开发规范/"},{"title":"实现一个简单的MVVM框架","text":"实现一个简单的MVVM框架 首先什么是 MVVMMVVM 是 Model-View-ViewModel 的简写。微软的 WPF 带来了新的技术体验，如 Silverlight、音频、视频、3D、动画……，这导致了软件 UI 层更加细节化、可定制化。同时，在技术层面，WPF 也带来了 诸如 Binding、Dependency Property、Routed Events、Command、DataTemplate、ControlTemplate 等新特性。MVVM（Model-View-ViewModel）框架的由来便是 MVP（Model-View-Presenter）模式与 WPF 结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有 MVP 框架并且把 WPF 的新特性糅合进去，以应对客户日益复杂的需求变化。 实现思路简单来看 MVVM 可以拆分成三部分：View 是视图界面，ViewModel 存放各种业务逻辑和网络请求。实现一个简单的 MVVM 框架，就需要将这三个部分组织起来。 具体实现思路：遍历 dom，替换相应的数据，绑定相应方法等。通过 defineProperty 进行数据劫持，当修改数据时进行视图变更。 类图 关键代码Latte 是整个框架的核心。定义了数据路径对象，获取需要处理的 dom，定义数据，方法。遍历 dom，替换 dom，完成数据劫持等操作。 1234567891011121314151617181920212223242526272829303132333435363738394041class Latte { constructor(latte) { if (!latte.el || !latte.data) { throw new Error(\"Latte need an object to observe.\"); } this.$data = latte.data; this.$register = new Register(); this.$el = document.querySelector(latte.el); this.$eventList = latte.eventList; this.$frag = Latte.node2Fragment(this.$el); this.scan(this.$frag); this.$el.appendChild(this.$frag); this.$register.build(); } // 取出原有的dom存放于fragment static node2Fragment(el) {} // 采用递归的方式，深层遍历dom。 // 如果没有list，那么就直接进行dom绑定事件，设置class，替换数据的操作。 scan(node) {} // 返回一个对象 {path, data} // path表示当前model在数据中的路径，data表示model的值。 parseData(str, node) {} // 判断需要绑定的事件类型，为dom绑定事件 parseEvent(node) {} // 为dom绑定class parseClass(node) {} //为dom替换相应的数据，并调用regist方法处理当数据变化时，更新视图 parseModel(node) {} // 处理list数据 parseList(node) {} //处理list数据中的每一项 parseListItem(node) {}} 其中 scan 通过迭代的方式，完成一个深度优先遍历。通过下面几种标识完成 dom 的解析。调用 parseEvent、parseClass、parseModel 方法，为相应的 dom 绑定事件，设置相应的 class，替换相应的数据等。 data-model——用于将 DOM 的文本节点替换为制定内容 data-class——用于将 DOM 的 className 替换为制定内容 data-list——用于标识接下来将出现一个列表，列表为制定结构 data-list-item——用于标识列表项的内部结构 data-event——用于为 DOM 节点绑定指定事件 首先要判断当前的 dom 不是 list，则直接进行 dom 绑定事件，设置 class，替换数据的操作。如果存在子节点则继续遍历。如果是 list 需要单独处理，单独对 list 的每一项进行同样的操作中，这里代码省略。 123456789101112131415161718192021222324252627scan(node) { if (node === this.$frag || !node.getAttribute('lait-list')) { let childs = []; if (node.children) { childs = [...node.children]; } else { [...node.childNodes].forEach((child) =&gt; { if (child.nodeType === 1) { childs.push(child); } }); } childs.forEach((child) =&gt; { if (node.path) { child.path = node.path; } this.parseEvent(child); this.parseClass(child); this.parseModel(child); if (child.children.length) { this.scan(child); } }); } else { this.parseList(node); }} 对于 model 的处理，根据 lait-model 得到 key，然后从 data 获取数据。如果当前 dom 时 input 时设置 value 为获取到的数据，其他情况都是设置其 innerText 。最后调用 register.regist 构建路径对象。 123456789101112131415161718parseModel(node) { if (node.getAttribute('lait-model')) { const modelName = node.getAttribute('lait-model'); const dataObj = this.parseData(modelName, node); if (node.tagName === 'INPUT') { node.value = dataObj.data; } else { node.innerText = dataObj.data; } this.$register.regist(this.$data, dataObj.path, (old, now) =&gt; { if (node.tagName === 'INPUT') { node.value = now; } else { node.innerText = now; } }); }} Register.regist 方法用来构建一个路径对象 routes ，每个路径对象包括数据的 value 值，当前数据在 model 的路径，当前数据拦截后触发的方法。build 方法用于给每个 model 设置数据拦截。 1234567891011121314151617181920212223242526272829303132class Register { constructor() { this.routes = []; } regist(obj, k, fn) { const route = this.routes.find(el =&gt; { let result; if ( (el.key === k || el.key.toString() === k.toString()) &amp;&amp; Object.is(el.obj, obj) ) { result = el; } return result; }); if (route) { route.fn.push(fn); } else { this.routes.push({ obj, key: k, fn: [fn] }); } } build() { this.routes.forEach(route =&gt; { observer(route.obj, route.key, route.fn); }); }} 对于 class 和 event 的处理方式与 model 类似，这里省略代码。 上文中提到的 observer 方法通过劫持数据的方式，在数据层发生变化时，视图层随之变化。对数据的劫持是通过 Object.defineProperty 方法进行的，当发现数据值改变了之后，调用相应的路径对象 routes 中定义的方法，更新 dom。由于数据复杂程度不同，因此这里需要分多种情况考虑：对于普通对象直接处理。对于嵌套对象，需要对嵌套的对象的每个属性进行劫持。对于复杂路径的数据，要先取到数据然后再进行处理。对于数组的 push、pop、shift、unshift、splice、sort、reverse 方法进行处理，触发视图更新。 下面只是对简单对象进行了处理，其他复杂情况只有个入口，具体省略 1234567891011121314151617181920212223242526272829303132function observer(obj, k, callback) { if (!obj || (!k &amp;&amp; k !== 0)) { throw new Error(\"Please pass an object to the observer.\"); } if (Object.prototype.toString.call(k) === \"[object Array]\") { observePath(obj, k, callback); } else { let old = obj[k]; if (!old) { throw new Error(\"The key to observe is undefined.\"); } if (Object.prototype.toString.call(old) === \"[object Array]\") { observeArray(old, callback); } else if (old.toString() === \"[object Object]\") { observeAllKey(old, callback); } else { Object.defineProperty(obj, k, { enumerable: true, configurable: true, get: () =&gt; old, set: now =&gt; { if (now !== old) { callback.forEach(fn =&gt; { fn(old, now); }); } old = now; } }); } }} 使用方法View 层代码： 12345678910111213141516&lt;ul lait-list=\"todos\"&gt; &lt;h1 lait-model=\"title\"&gt;&lt;/h1&gt; &lt;div&gt; &lt;li lait-list-item=\"todos\"&gt; &lt;p lait-class=\"todos:done\" lait-model=\"todos:creator\"&gt;&lt;/p&gt; &lt;p lait-model=\"todos:date\"&gt;&lt;/p&gt; &lt;p lait-model=\"todos:content\"&gt;&lt;/p&gt; &lt;ul lait-list=\"todos:members\"&gt; &lt;li lait-list-item=\"todos:members\"&gt; &lt;span lait-model=\"todos:members:name\"&gt;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/div&gt;&lt;/ul&gt;&lt;button lait-event=\"click\"&gt;添加&lt;/button&gt; Model 层代码： 1234567891011121314151617181920let data = { title: \"todo list!\", user: \"mirone\", todos: [ { creator: \"keal\", done: \"undone\", content: \"writeMVVM\", date: \"2016-11-17\", members: [{ name: \"kaito\" }, { name: \"hito\" }, { name: \"QAQ\" }] }, { creator: \"mirone\", done: \"done\", content: \"writeNode\", date: \"2016-12-17\", members: [{ name: \"hitomiao\" }, { name: \"miaomiao\" }] } ]}; ViewModel 层代码： 123456789101112131415161718new Latte({ el: \"#root\", data, eventList: { click: { type: \"click\", fn: function() { data.todos.push({ creator: \"k\", done: \"undone\", date: \"2016-12-24\", content: \"get mvvm\", members: [{ name: \"hito\" }] }); } } }}); 最终显示效果：","link":"/2018/01/12/2018/01/实现一个简单的MVVM框架/"},{"title":"深入理解vue","text":"vue源码分析、手写响应式原理等。 写在前面vue 与 juqery 的区别通过 TODO List 实现的例子总结得出 1.数据视图分离，解耦（开放封闭原则：对扩展开放，对修改封闭）。2.数据驱动视图，只关心数据变化，dom 操作被封装。 MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 View 了解 Controller，Controller 了解 Model，而 View 能够直接访问 Model。例如用户点击了一个按钮（操作了视图），然后 controller 进行业务逻辑操作，最后将操作结果发送给视图。 MVVM M 数据，对应于 vue 中的 data V 视图，对应于 DOM VM 视图模型，对应于 vue 实例 视图通过事件绑定，经过视图模型操作数据，数据通过数据绑定，经过视图模型修改视图 源码分析思路过程首先文档，然后通过一个简单的例子开始，从入口文件一步步分析，抓住主线。vue 组件通常都有一个 install 方法，用于将组件装在到 vue 对象上。 vue 声明周期vue 生命周期深入 vue 源码分析推荐文章 Vue 源码学习 vue 三要素 响应式：监听数据变化。 模板引擎：解析模板指令。 渲染：模板结合 modal 如何生成 DOM，当产生变化时更新 DOM。 vue 构造函数整体流程如下：1、Vue.prototype 下的属性和方法的挂载主要是在 src/core/instance 目录中的代码处理的。2、Vue 下的静态属性和方法的挂载主要是在 src/core/global-api 目录下的代码处理的。3、web-runtime.js 主要是添加 web 平台特有的配置、组件和指令，web-runtime-with-compiler.js 给 Vue 的$mount 方法添加 compiler 编译器，支持 template。 初始化，绑定原型对象属性定义 Vue 构造函数，然后以 Vue 构造函数为参数，调用了五个方法，最后导出 Vue。这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性。 12345678910111213function Vue (options) { if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue)) { warn('Vue is a constructor and should be called with the `new` keyword') } this._init(options)}// initMixin(Vue) 初始化入口 src/core/instance/init.js// stateMixin(Vue) 数据绑定，$watch方法 src/core/instance/state.js// renderMixin(Vue) 渲染方法，用来生成render function 和 VNode src/core/instance/render.js// eventsMixin(Vue) 事件方法，比如$on,$off,$emit src/core/instance/events.js// lifecycleMixin(Vue) 生命周期方法 src/core/instance/lifecycle.js 绑定静态属性和方法导入上文导出的 Vue（已经在原型上挂载了方法和属性），将 Vue 作为参数传给 initGlobalAPI ，最后又在 Vue.prototype 上挂载了 $isServer，在 Vue 上挂载了 version 属性。 安装指令和组件覆盖 Vue.config 的属性，将其设置为平台特有的一些方法。Vue.options.directives 和 Vue.options.components 安装平台特有的指令和组件。在 Vue.prototype 上定义__patch__和 $mount。 覆盖$mount,编译模板函数缓存来自 web-runtime.js 文件的$mount函数，然后覆盖覆盖了Vue.prototype.$mount。在 Vue 上挂载 compile，compileToFunctions 函数的作用，就是将模板 template 编译为 render 函数。 整体来看执行顺序12345678910initLifecycle(vm)initEvents(vm)callHook(vm, 'beforeCreate')initProps(vm)initMethods(vm)initData(vm)initComputed(vm)initWatch(vm)callHook(vm, 'created')initRender(vm) 数据响应系统模型通过 Observer、Dep、Watcher、Directive 等一系列对象的关联，最终和视图建立起关系。推荐文章Vue 源码解析：深入响应式原理 通过 Observer 对 data 做监听，并且提供了订阅某个数据项变化的能力。 把 template 编译成一段 document fragment，然后解析其中的 Directive，得到每一个 Directive 所依赖的数据项和 update 方法。 通过 Watcher 把上述两部分结合起来，即把 Directive 中的数据依赖通过 Watcher 订阅在对应数据的 Observer 的 Dep 上。当数据变化时，就会触发 Observer 的 Dep 上的 notify 方法通知对应的 Watcher 的 update，进而触发 Directive 的 update 方法来更新 DOM 视图，最后达到模型和视图关联起来。 通过一个简单的例子来看一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var data = { name: 'chenjp', age: 25, school: { text: 'NCU', major: 'computer' }}observer(data)new Watch('name', function (oldVal, newVal) { console.log('name changed', oldVal, newVal) console.log(data) // 这里data还是原来的，没变})function Watch(exp, fn) { this.exp = exp this.fn = fn pushTarget(this) data[exp] // 触发get，与observer关联}// 依赖管理function Dep() { this.subs = [] this.depend = function () { this.subs.push(Dep.target) } this.notify = function (oldVal, newVal) { for (let i = 0; i &lt; this.subs.length; i++) { this.subs[i].fn(oldVal, newVal) } }}Dep.target = nullfunction pushTarget(watch) { Dep.target = watch}//将数据对象data的属性转换为访问器属性function observer(thisData) { if (Object.prototype.toString.call(thisData) === '[object Object]') { for (let item in thisData) { let dep = new Dep() let val = thisData[item] observer(val) Object.defineProperty(thisData, item, { enumerable: true, configurable: true, get: function () { // 添加依赖 dep.depend() return val }, set: function (newVal) { if (val === newVal) { return } observer(newVal) // 触发依赖 dep.notify(val, newVal) } }) } } else { return }} 渲染与重新渲染模板-&gt;render 函数-&gt;DOM。将 template 编译成 render 函数，这个函数返回一个虚拟 dom 节点，最终渲染成 dom。当 render 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照 Vue 中 watcher.js 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍。 vm_render 方法最终返回一个 vnode 对象，即虚拟 DOM，然后作为 vm_update 的第一个参数传递了过去，我们看一下 vm_update 的逻辑：如果还没有 prevVnode 说明是首次渲染，直接创建真实 DOM。如果已经有了 prevVnode 说明不是首次渲染，那么就调用 patch 函数，patch 函数用新的 vnode 和老的 vnode 进行 diff，最后完成 dom 的更新工作。这就是 Vue 更新 DOM 的逻辑。 vue 数据绑定预渲染总结实例化一个 watcher，在求值的过程中 this.value = this.lazy ? undefined : this.get()，会调用 this.get()方法，因此在实例化的过程当中 Dep.target 会被设为这个 watcher，通过调用 vm._render()方法生成新的 Vnode 并进行 diff 的过程中完成了模板当中变量依赖收集工作。即这个 watcher 被添加到了在模板当中所绑定变量的依赖当中。一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify()方法完成所有依赖遍历执行的工作，这里面就包括了视图的更新即。 总结：vue 整个的实现流程第一步：解析模板成 render 函数第二步：响应式开始监听第三步：首次渲染，显示页面，且绑定依赖第四部：data 属性变化，触发 set 监听执行 updateComponent 方法，然后触发 rernder 函数（render 函数再次执行，重新 patch） 虚拟 DOMvdom 很好的将 dom 做了一层映射关系vdom 完全是用 js 去实现，和宿主浏览器没有任何联系这里就分享两篇写的非常好的文章吧推荐文章Vue 2.0 的 virtual-dom 实现简析,深入 Vue2.x 的虚拟 DOM diff 原理,从 $mount 讲起，一起探究 Vue 的渲染机制 总结：在 initRender(vue 构造函数中的五个方法中最后一个)中如果有 vm.$options.el 还要调用 vm.$mount(vm.$options.el)，实际上是调用了 src/core/instance/lifecycle.js 中的 mountComponent 方法，mountComponent 函数如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component { // vm.$el为真实的node vm.$el = el // 如果vm上没有挂载render函数 if (!vm.$options.render) { // 空节点 vm.$options.render = createEmptyVNode } // 钩子函数 callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) { ... } else { // updateComponent为监听函数, new Watcher(vm, updateComponent, noop) updateComponent = () =&gt; { // Vue.prototype._render 渲染函数 // vm._render() 返回一个VNode // 更新dom // vm._render()调用render函数，会返回一个VNode，在生成VNode的过程中，会动态计算getter,同时推入到dep里面 vm._update(vm._render(), hydrating) } } // 新建一个_watcher对象 // vm实例上挂载的_watcher主要是为了更新DOM // vm/expression/cb vm._watcher = new Watcher(vm, updateComponent, noop) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } return vm} 注意上面的代码中定义了一个 updateComponent 函数，这个函数执行的时候内部会调用vm._update(vm._render(), hyddrating)方法，其中vm._render方法会返回一个新的 vnode，然后传入 vm._update 方法后，就用这个新的 vnode 和老的 vnode 进行 diff，最后完成 dom 的更新工作。那么 updateComponent 都是在什么时候去进行调用呢？ 1vm._watcher = new Watcher(vm, updateComponent, noop) 实例化一个 watcher，在求值的过程中 this.value = this.lazy ? undefined : this.get()，会调用 this.get()方法，因此在实例化的过程当中 Dep.target 会被设为这个 watcher，通过调用 vm._render()方法生成新的 Vnode 并进行 diff 的过程中完成了模板当中变量依赖收集工作。即这个 watcher 被添加到了在模板当中所绑定变量的依赖当中。一旦 model 中的响应式的数据发生了变化，这些响应式的数据所维护的 dep 数组便会调用 dep.notify()方法完成所有依赖遍历执行的工作，这里面就包括了视图的更新即 updateComponent 方法，它是在 mountComponent 中的定义的。 vue-router 原理推荐文章vue-router 实现分析,vue-router 源码分析-整体流程 通过 vue 的插件机制，在 vue.use(VueRouter)时，调用了 vueRouter 组件中的 install 方法，install 方法中通过 vue 的 mixin，在 beforeCreate 时执行 init 方法，init 方法中通过监听 hashChange 事件来监听路由变化。当监听到 hashChange 时，执行 history.transitionTo(…)，在这个过程中，会进行地址匹配，得到一个对应当前地址的 route，然后将其设置到对应的 vm._route 上。在 beforeCreate 中还采用与 Vue 本身数据相同的“数据劫持”方式，对 vm._route 的赋值会被 Vue 拦截到，并且触发 Vue 组件的更新渲染流程。 1Vue.util.defineReactive(this, '_route', this._router.history.current) 视图更新进一步调用到 router-view 组件的 render() 方法。主要逻辑是从根组件中取出当前的路由对象（parent.$route），然后取得该路由下对应的组件，然后交由该组件进行渲染。 vuex 原理推荐文章Vuex 框架原理与源码分析，Vuex 2.0 源码分析管理页面数据，提供统一操作处理action-mutation-stateChangeVue 组件接收交互行为，调用 dispatch 方法触发 action 相关处理，若页面状态需要改变，则调用 commit 方法提交 mutation 修改 state，通过 getters 获取到 state 新值，重新渲染 Vue Components，界面随之更新。 install 方法给 Vue 的实例注入一个 $store 的属性。 Vuex 的初始化的核心，其中，installModule 方法是把我们通过 options 传入的各种属性模块注册和安装；resetStoreVM 方法是初始化 store._vm，观测 state 和 getters 的变化；最后是应用传入的插件。 严格模式做的事情很简单，监测 store._vm.state 的变化，看看 state 的变化是否通过执行 mutation 的回调函数改变，如果是外部直接修改 state，那么 store._committing 的值为 false，这样就抛出一条错误。 webpack推荐文章深入浅出 Webpack 一些重点概念 Entry：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 Loader：模块转换器，用于把模块原内容按照需求转换成新内容。 Plugin：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 Output：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。 通常你可用如下经验去判断如何配置 Webpack： 想让源文件加入到构建流程中去被 Webpack 控制，配置 entry。 想自定义输出文件的位置和名称，配置 output。 想自定义寻找依赖模块时的策略，配置 resolve。 想自定义解析和转换文件的策略，配置 module，通常是配置 module.rules 里的 Loader。 其它的大部分需求可能要通过 Plugin 去实现，配置 plugin。","link":"/2018/03/24/2018/03/深入理解vue/"},{"title":"深入基础-css篇","text":"盒模型。 BFC块级格式化上下文。 布局。局中布局、三栏布局。 弹性布局。 伪类与为元素。 清除浮动。 单位。 百分比参照。 盒模型content+padding+border+margin 类别 W3C 标准盒模型 width=content IE 盒模型 width = content+padding+border box-sizing content-box W3C 标准盒模型 border-box IE 盒模型 BFC块级格式化上下文。它是页面中的一块渲染区域，有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 “封闭的大箱子”具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 触发 body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 弹性盒子 flex 作用 同一个 BFC 容器会发生折叠，不同 BFC 容器不会折叠 清除浮动 实现一列顶宽，另一列自适应布局 1234567&lt;div style=\"height: 100px;width: 100px;float: left;background: lightblue\"&gt; 我是一个左浮动的元素&lt;/div&gt;&lt;div style=\"width: 200px; height: 200px;background: #eee\"&gt; 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 上边的代码将产生文字环绕效果。将第二个元素添加 overflow:auto 实现一列定宽，另一列自适应布局。 布局居中水平居中 定宽块状元素：margin auto 行内元素：父元素 text-align:center 非定宽块状元素：父容器 text-align:center，自身 display:inline 父容器为相对定位，子元素绝对定位，left为50%，利用transform水平平移translateX(-50%)。 父容器为相对定位，子元素绝对定位、定宽，left为50%，margin-left为居中元素宽度的一半。 通用：父容器 flex 布局，justify-content:center 垂直居中 内联单行： line-height 等于 height 内联多行：父容器 display:table。自身 display:table-cell；vertical-align:middle 块状元素：父容器非 static，自身 absolute，top、bottom 为 0，margin:auto 父容器为相对定位，子元素绝对定位，top为50%，利用transform垂直平移translateY(-50%)。 通用： 父容器 flex，align-items:center 水平垂直居中 absolute + transform inline-bock + text-align + table-cell + vertical-align flex + justify-content + align-items 两列、三列布局float+margin注意顺序：先两侧，后中间。这样就没有优先渲染你最重要的部分了。 12345&lt;div class=\"content\"&gt; &lt;div class=\"sub\"&gt;sub&lt;/div&gt; &lt;div class=\"extra\"&gt;extra&lt;/div&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt;&lt;/div&gt; 1234567891011.sub { width: 200px; float: left;}.extra { width: 200px; float: right;}.main { margin: 0 200px;} position+margin无书 DOM 写顺序限制如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。 12345&lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"sub\"&gt;sub&lt;/div&gt; &lt;div class=\"extra\"&gt;extra&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.content { position: relative;}.sub { width: 200px; position: absolute; top: 0; left: 0;}.extra { width: 200px; position: absolute; top: 0; right: 0;}.main { margin: 0 200px;} 圣杯布局dom 顺序不可变。当中间区域小于两侧区域宽度时布局会错乱。限制 content 最小宽度。 12345&lt;div class=\"content\"&gt; &lt;div class=\"main\"&gt;main&lt;/div&gt; &lt;div class=\"sub\"&gt;sub&lt;/div&gt; &lt;div class=\"extra\"&gt;extra&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021.content { padding: 0 200px;}.main { float: left; width: 100%;}.sub { width: 200px; float: left; margin-left: -100%; position: relative; left: -200px;}.extra { width: 200px; float: right; margin-right: -200px; position: relative; right: -200px;} 双飞翼布局12345678910&lt;div class=\"content\"&gt; &lt;div class=\"main-wrap\"&gt; &lt;div class=\"main\"&gt; main &lt;/div&gt; &lt;/div&gt; &lt;div class=\"sub\"&gt;sub&lt;/div&gt; &lt;div class=\"extra\"&gt;extra&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.main-wrap { float: left; width: 100%;}.main { margin: 0 200px 0 290px;}.sub { float: left; width: 290px; margin-left: -100%;}.extra { float: left; width: 200px; margin-left: -200px;} flex 布局弹性布局 flex在 flex 为 1 的容器中，子元素 height：100%，但子元素内内容超过 100%后，子容器会大于 100%的 bug。通过 absolute 可以解决此问题。参考链接 作用于父容器flex-flowflex-directionrowrow-reversecolumncolumn-reverse flex-wrapnowrapwrapwrap-reverse justify-contentflex-startcenterflex-endspace-betweenspace-around align-itemsflex-startcenterflex-endbaselinestretch align-content （多跟轴线的对其方式）flex-startcenterflex-endspace-betweenspace-aroundstretch 作用于子元素分支主题order数字越小越靠前 flexflex-grow默认值为 0，有空间也不占 不为零时按占比分配大小 flex-shrink默认值为 1，空间不足时将缩小 为零时不缩小 一个为 1，一个为 2 的两个 div缩小时值越大的缩小越快 flex-basicalign-selfautoflex-startflex-endcenterbaselinestretch 伪类、伪元素伪类定义的是状态 :root 选择文档的根元素，等同于 html 元素:empty 选择没有子元素的元素:target 选取当前活动的目标元素:not(selector) 选择除 selector 元素意外的元素:enabled 选择可用的表单元素:disabled 选择禁用的表单元素:checked 选择被选中的表单元素:nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n，从后向前数:nth-child(odd) 、 :nth-child(even) 、 :nth-child(3n+1):first-child 、 :last-child 、 :only-child:nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n，从后向前数:nth-of-type(odd) 、 :nth-of-type(even) 、 :nth-of-type(3n+1):first-of-type 、 :last-of-type 、 :only-of-type 伪元素不存在于 DOM 树中的虚拟元素，它们可以像正常的 html 元素一样定义 css，但无法使用 JavaScript 获取。 ::after 已选中元素的最后一个子元素::before 已选中元素的第一个子元素::first-letter 选中某个款级元素的第一行的第一个字母::first-line 匹配某个块级元素的第一行::selection 匹配用户划词时的高亮部分 清除浮动clear作用于和浮动元素同级的元素 overflow作用于父级元素 伪元素作用于父级元素 1234567.clearFloat::after { content: \"\"; clear: both; display: block; height: 0; visibility: hidden;} 单位px1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\" /&gt; content 属性值 : width:可视区域的宽度，值可为数字或关键词 device-widthheight:可视区域的高度，值可为数字或关键词 device-heightintial-scale:页面首次被显示是可视区域的缩放级别，取值 1.0 则页面按实际尺寸显示，无任何缩放maximum-scale=1.0, minimum-scale=1.0;可视区域的缩放级别，maximum-scale 用户可将页面放大的程序，1.0 将禁止用户放大到实际尺寸之上。user-scalable:是否可对页面进行缩放，no 禁止缩放 em相对于本身或父容器字体大小rem1234567891011121314const fontFun = function() { let docEl = document.documentElement; let resizeEvt = \"orientationchange\" in window ? \"orientationchange\" : \"resize\"; const recalc = function() { let clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 750) + \"px\"; }; if (!document.addEventListener) return; window.addEventListener(resizeEvt, recalc, false); window.addEventListener(\"pageshow\", recalc, false); document.addEventListener(\"DOMContentLoaded\", recalc, false);}; 相对于 HTML 字体大小rpx小程序，按设计稿尺寸即可百分比参照margin/padding 的 top/right/bottom/left 百分比值都根据父容器 content 的宽度决定","link":"/2019/09/15/2019/09/深入基础-css篇/"},{"title":"深入基础-js篇-原型","text":"js中原型的规则 什么是原型链 原型模式。原型对象prototype。prototype的属性与方法。原型对象存在的问题与解决方法。 继承。原型链继承，借助构造函数继承，两者结合。 new。实现原理。 class的使用与原理。 js中原型的规则 所有的引用类型（数组、对象、函数），都具有对象特征，即可自由扩展属性； 所有的引用类型，都有一个_proto_ 属性（隐式原型），属性值是一个普通对象； 所有函数，都具有一个prototype（显示原型），他是一个指针，指向一个对象，这个对象存放着所有实例共享的属性和方法； 所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型；（obj._proto_ === Object.prototype）； 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的 prototype）中去寻找； 原型链当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_，还是没有就再找_prop_._prop_。 原型模式12345678function Person() {}Person.prototype.name = \"caixukun\";Person.prototype.age = 20;Person.prototype.sayName = function() { console.log(this.name);};let person = new Person(); 原型对象 prototypeprototype 就是 person 实例的原型对象。 原型对象 prototype 的 constructorPerson.prototype.constructor 指向 Person prototype.isPrototypeOf()判断 person 实例的_prop_是否指向构造函数的原型对象 Person.prototype。 只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。 12Person.prototype.isPrototypeOf(person); // trueperson._prop_ === Person.prototype; Object.getPrototypeOf()用于获取对象的prop Object.hasOwnPrototype()检测属性来自于实例（返回 true）还是原型（返回 false）。 in判断对象是否能够访问给定的属性。 Object.keys()返回对象上所有可枚举的实例属性。 getOwnPrototypeNames()返回对象上无论是否可枚举的实例属性。 Object.defineProperty()1234567891011121314// Person.prototype.constructor将被覆盖Person.prototype = { name: \"jay zhou\", age: 40};// 这样是的constructor属性变成了可枚举enumberablePerson.prototype.constructor = Person;// 最后通过defineProperty来设置Object.defineProperty(Person.prototype, constructor, { enumberable: false, value: Person}); 原型的动态性对原型的修改会从实例上反映出来。因为实例与原型之间通过指针连接，而不是一个副本。 重写原型对象时，切断了现有原型与任何之前已经存在了的对象实例之间的联系，他们引用的仍然是之前的原型。 存在的问题引用类型值的情况下，如果希望实例间的属性相互独立，就会产生问题。 12345678910function Person() {}Person.prototype.friends = [\"caixukun\", \"jay zhou\"];var person1 = new Person();var person2 = new Person();person1.friends.push(\"chenjp\");person1.friends; // 'caixukun,jay zhou, chenjp'person2.friends; // 'caixukun,jay zhou, chenjp' 构造函数模式 + 原型模式 （推荐）通过构造函数模式结合原型模式可以解决上边的问题。 123456789101112131415function Person(name) { this.name = name; this.friends = [\"caixukun\", \"jay zhou\"];}Person.prototype.sayName = function() { console.log(this.name);};var person1 = new Person(\"sam\");var person2 = new Person(\"lily\");person1.friends.push(\"chenjp\");person1.friends; // 'caixukun,jay zhou, chenjp'person2.friends; // 'caixukun,jay zhou' 动态原型模式通过在构造函数中检查是否存在，来决定是否初始化原型。 继承原型链继承让子类型的原型等于父类型的实例。Cat.prototype = new Animal()父类型中的引用类型会产生问题。像下面的例子，eat 属性转移到了 Cat.prototype。 1234567891011121314151617181920212223function Animal() { this.species = \"动物\"; this.eat = [\"water\"];}Animal.prototype.saySpecies = function() { console.log(this.species);};function Cat() { this.name = \"猫\";}Cat.prototype = new Animal();Cat.prototype.say = function() { console.log(\"喵\");};var cat1 = new Cat();cat1.eat.push(\"fish\");var cat2 = new Cat();cat1.eat; // 'water'、'fish'cat2.eat; // 'water'、'fish' 借助构造函数继承子类型的构造函数中调用超类型的构造函数。Animal.call(this)超类型中原型上定义的方法，子类型中不可见。cat1 无法访问 saySpecies 方法。 12345678910111213141516171819202122232425function Animal() { this.species = \"动物\"; this.eat = [\"water\"];}Animal.prototype.saySpecies = function() { console.log(this.species);};function Cat() { Animal.call(this); this.name = \"猫\";}Cat.prototype.say = function() { console.log(\"喵\");};var cat1 = new Cat();cat1.eat.push(\"fish\");var cat2 = new Cat();cat1.eat; // 'water'、'fish'cat2.eat; // 'water'cat1.saySpecies(); // cat1.saySpecies is not a function 原型链继承 + 构造函数继承 (推荐)原型链实现了对原型属性和方法的继承，构造函数实现了对实例属性的继承。 1234567891011121314151617181920212223242526function Animal() { this.species = \"动物\"; this.eat = [\"water\"];}Animal.prototype.saySpecies = function() { console.log(this.species);};function Cat() { Animal.call(this); this.name = \"猫\";}Cat.prototype = new Animal();Cat.prototype.constructor = Cat;Cat.prototype.say = function() { console.log(\"喵\");};var cat1 = new Cat();cat1.eat.push(\"fish\");var cat2 = new Cat();cat1.eat; // 'water'、'fish'cat2.eat; // 'water'cat1.saySpecies(); // 动物 原型式继承仅用于让一个对象与另一个对象保持类似的情况。引用类型会产生问题。 1234567891011121314151617var animal = { species: \"动物\", eat: [\"water\"], saySpecies: function() { console.log(this.species); }};var cat1 = Object.create(animal);cat1.name = \"猫1\";cat1.eat.push(\"fish\");var cat2 = Object.create(animal);cat2.name = \"猫2\";animal.friends = [1, 2, 3, 4];cat1.friends; // [1, 2, 3, 4] 寄生式继承不能复用函数。 1234567891011121314151617function createAnother(original) { var clone = Object.create(original); clone.sayHi = function() { console.log(\"hi\"); }; return clone;}var animal = { species: \"动物\", eat: [\"water\"], saySpecies: function() { console.log(this.species); }};var cat1 = createAnother(animal); newnew Fn() 之后发生了什么 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。 12345678910function create(fn) { // 创建一个空的对象 let obj = new Object() // 链接到原型 obj.__proto__ = fn.prototype // 绑定 this，执行构造函数 let result = fn.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj} es6 class实现原理ES6类以及继承的实现原理 123456789101112131415161718192021222324252627282930313233343536373839404142434445\"use strict\";var _createClass = (function() { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; };})();function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); }}var Parent = (function() { function Parent(name, age) { _classCallCheck(this, Parent); this.name = name; this.age = age; } _createClass(Parent, [ { key: \"speakSomething\", value: function speakSomething() { console.log(\"I can speek chinese\"); } } ]); return Parent;})();","link":"/2019/09/15/2019/09/深入基础-js篇-原型/"},{"title":"深入基础-js篇-作用域与闭包","text":"作用域。作用域链在函数定义时创建好的。 执行上下文（变量对象、活动对象、作用域链、this）。this是函数运行时所在的环境。call、apply、bind的具体实现。 闭包。应用（防抖、节流、柯里化）。 内存。内存泄漏、内存溢出。 模块化。import/export、module/require、define 作用域JavaScript 深入之词法作用域和动态作用域 作用域规定了如何查找变量，也就是当前执行的代码对变量访问的权限 静态作用域（也叫词法作用域）和动态作用域JavaScript 采用的是静态作用域。 静态、动态作用域都是先从自己的函数内部查找，找不到后：静态作用域：根据书写的位置，在上面一层的代码查找。（定义时）动态作用域：在调用函数的作用域中查找。（执行时） 123456789101112var value = 1;function foo() { console.log(value);}function bar() { var value = 2; foo();}bar(); 作用域链在函数定义时创建函数的作用域基于函数创建的位置。函数的执行用到了作用域链，这个作用域链是在函数定义时创建的。 123456789var scope = \"global scope\";function checkscope() { var scope = \"local scope\"; function f() { return scope; } return f();}checkscope(); 123456789var scope = \"global scope\";function checkscope() { var scope = \"local scope\"; function f() { return scope; } return f;}checkscope()(); 执行上下文分类 全局执行上下文 函数执行上下文 eval函数执行上下文 执行上下文创建过程建立阶段：(函数被调用，但是还未执行函数中的代码) 创建变量，参数，函数，arguments对象 建立作用域链 确定this的值 执行阶段：变量赋值，函数引用，执行代码 变量对象(VO)存放着该执行上下文中的所有变量和函数。 活动对象(AO)执行到一个上下文时，该上下文中的变量与函数都可以被访问到，也就是被激活 作用域链(Scope chain)当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 thisthis 指的是函数运行时所在的环境。 不同情况下 this 的值 全局环境中 函数（运行环境内）调用 简单的函数调用 严格模式函数调用（指向函数内环境 undefind） 箭头函数 （设置为他被创建时的环境） 使用 call、apply、bind 调用时 作为对象的方法 取决于最近的对象 原型链中 setter、getter 在构造函数中 在 dom 监听事件中（target） 改变 this 的指向call 接受一个参数列表。apply 接受一个数组。bind 返回一个函数。 例如改变 test 函数的 this 指向为 newThis模拟实现思路，newThis 添加一个属性，值为 test 函数，然后在执行完以后删除 callcall() 接受一个参数列表,并执行函数。 123456789Function.prototype.myCall = function(context = window, ...args) { context.__fn__ = this; const result = context.__fn__(...args); delete context.__fn__; return result;}; applyapply() 接受一个数组,并执行函数。 123456789Function.prototype.myApply = function(context = window, args = []) { context.__fn__ = this; const result = context.__fn__(...args); delete context.__fn__; return result;}; bindbind() 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 JavaScript 深入之 bind 的模拟实现 bind函数以下的特点需要注意： bind传入一部分参数。 当bind返回的函数作为构造函数的时候，bind指定的 this 值会失效，但传入的参数依然生效 我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转。 123456789101112131415161718192021222324252627Function.prototype.myBind = function(context, ...bindArgs) { if (typeof this !== \"function\") { throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); } var self = this; var fNOP = function() {}; fNOP.prototype = this.prototype; var fBound = function(...args) { // 当作为构造函数时，this 指向实例，此时结果为 true， // 将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 当作为普通函数时，this 指向 window，此时结果为 false， // 将绑定函数的 this 指向 context return self.apply( this instanceof fNOP ? this : context, bindArgs.concat(args) ); }; fBound.prototype = new fNOP(); return fBound;}; 闭包闭包是指那些能够访问自由变量（在函数中使用的，但既不是函数参数也不是函数的局部变量的变量）的函数。 作用域链的作用1234567891011var scope = \"global scope\";function checkscope() { var scope = \"local scope\"; function f() { return scope; } return f;}var foo = checkscope();foo(); 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？因为 f 执行上下文维护了一个作用域链。 老套路1234567891011var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = function() { console.log(i); };}data[0]();data[1]();data[2](); 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) { data[i] = (function(i) { return function() { console.log(i); }; })(i);}data[0]();data[1]();data[2](); 闭包的应用防抖函数 debounce超过指定时间间隔才会执行 123456789function debounce(fn, interval = 300) { var timer; return function(...args) { clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apllay(this, args); }, interval); };} 节流函数 throttle指定时间间隔内只会执行一次 1234567891011function throttle(fn, interval = 300) { var canRun = true; return function(...args) { if (!canrun) return; canrun = false; setTimeout(() =&gt; { fn.applay(this, args); canrun = true; }, interval); };} 柯里化 curring1234567891011121314151617181920function currying(fn, isEnd = false, ...args) { if (isEnd) { return fn(...args); } else { return function(...args2) { return currying(fn, args2.length === 0, ...args, ...args2); }; }}function add(...args) { return args.reduce((acc, cur) =&gt; { return acc + cur; }, 0);}var sum = currying(add);sum(1)();sum(1)(2)(3)(4)();sum(1)(2)(3)(4)(5)(6)(); 内存内存泄漏JavaScript 中的内存泄漏以及如何处理 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之，就是内存泄漏了。 不必要的全局变量 被遗忘的计时器或回调 闭包 超出 DOM 引用 内存溢出模块化对于 CommonJS 和 ES6 中的模块化的两者区别是： 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 es6CommonJS12345678910// a.jsmodule.exports = { a: 1};// orexports.a = 1;// b.jsvar module = require(\"./a.js\");module.a; // -&gt; log 1 AMD12345678910define([\"./a\", \"./b\"], function(a, b) { a.do(); b.do();});define(function(require, exports, module) { var a = require(\"./a\"); a.doSomething(); var b = require(\"./b\"); b.doSomething();});","link":"/2019/09/15/2019/09/深入基础-js篇-作用域与闭包/"},{"title":"深入基础-js篇-异步","text":"异步编程的三个阶段： promise。promise的常用方法。then的链式调用。 generator。自动执行。 async。优势与注意事项。 promise promise 是一个存放着异步操作结果的容器，是一个可以从他获取异步操作消息的对象。 Promise 是生成 promise 的构造函数。 三种状态：pending（进行中）、fulfilled（已成功）、reject（已失败）。状态一旦改变就不会再变了。 promise 新建后就会立即执行 常用方法then12345678910111213141516171819202122232425262728293031323334353637function start() { return new Promise((resolve, reject) =&gt; { resolve(\"start\"); });}start() .then(data =&gt; { // promise start console.log(\"result of start: \", data); return Promise.resolve(1); // p1 }) .then(data =&gt; { // promise p1 console.log(\"result of p1: \", data); return Promise.reject(2); // p2 }) .then(data =&gt; { // promise p2 console.log(\"result of p2: \", data); return Promise.resolve(3); // p3 }) .catch(ex =&gt; { // promise p3 console.log(\"ex: \", ex); return Promise.resolve(4); // p4 }) .then(data =&gt; { // promise p4 console.log(\"result of p4: \", data); });// 上面的代码最终会输出：// result of start: start// result of p1: 1// ex: 2// result of p4: 4 finallyallraceresolverejecttry同步函数同步执行，异步函数异步执行 实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211// 判断变量否为functionconst isFunction = variable =&gt; typeof variable === \"function\";// 定义Promise的三种状态常量const PENDING = \"PENDING\";const FULFILLED = \"FULFILLED\";const REJECTED = \"REJECTED\";class MyPromise { constructor(handle) { if (!isFunction(handle)) { throw new Error(\"MyPromise must accept a function as a parameter\"); } // 添加状态 this._status = PENDING; // 添加状态 this._value = undefined; // 添加成功回调函数队列 this._fulfilledQueues = []; // 添加失败回调函数队列 this._rejectedQueues = []; // 执行handle try { handle(this._resolve.bind(this), this._reject.bind(this)); } catch (err) { this._reject(err); } } // 添加resovle时执行的函数 _resolve(val) { const run = () =&gt; { if (this._status !== PENDING) return; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; { let cb; while ((cb = this._fulfilledQueues.shift())) { cb(value); } }; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; { let cb; while ((cb = this._rejectedQueues.shift())) { cb(error); } }; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) { val.then( value =&gt; { this._value = value; this._status = FULFILLED; runFulfilled(value); }, err =&gt; { this._value = err; this._status = REJECTED; runRejected(err); } ); } else { this._value = val; this._status = FULFILLED; runFulfilled(val); } }; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); } // 添加reject时执行的函数 _reject(err) { if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; { this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) { cb(err); } }; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); } // 添加then方法 then(onFulfilled, onRejected) { const { _value, _status } = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; { // 封装一个成功时执行的函数 let fulfilled = value =&gt; { try { if (!isFunction(onFulfilled)) { onFulfilledNext(value); } else { let res = onFulfilled(value); if (res instanceof MyPromise) { // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); } else { //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); } } } catch (err) { // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); } }; // 封装一个失败时执行的函数 let rejected = error =&gt; { try { if (!isFunction(onRejected)) { onRejectedNext(error); } else { let res = onRejected(error); if (res instanceof MyPromise) { // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); } else { //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); } } } catch (err) { // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); } }; switch (_status) { // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; } }); } // 添加catch方法 catch(onRejected) { return this.then(undefined, onRejected); } // 添加静态resolve方法 static resolve(value) { // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); } // 添加静态reject方法 static reject(value) { return new MyPromise((resolve, reject) =&gt; reject(value)); } // 添加静态all方法 static all(list) { return new MyPromise((resolve, reject) =&gt; { /** * 返回值的集合 */ let values = []; let count = 0; for (let [i, p] of list.entries()) { // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; { values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); }, err =&gt; { // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); } ); } }); } // 添加静态race方法 static race(list) { return new MyPromise((resolve, reject) =&gt; { for (let p of list) { // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; { resolve(res); }, err =&gt; { reject(err); } ); } }); } finally(cb) { return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; { throw reason; }) ); }} generator1234567891011121314function* gen(arg) { yield 2; yield arg;}let genHandle = gen(3);for (let i of genHandle) { console.log(i); // 依次打印：2，3}let genHandle2 = gen(4);console.log(genHandle2.next()); // { value: 2, done: false }console.log(genHandle2.next()); // { value: 4, done: false }console.log(genHandle2.next()); // { value: undefined, done: true } 转换成 es5 的代码大致为下面的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var context = { next: 0, prev: null, gen$: null, done: false, stop: function() { this.done = true; }};Object.defineProperty(context, Symbol.iterator, { enumerable: false, writable: false, configurable: true, value: function() { var me = this; return { next: function() { var nextValue = me.gen$(me); return { value: nextValue, done: me.done }; } }; }});var regeneratorRuntime = { wrap: function(_gen) { context.gen$ = _gen; return context; }};function gen(arg) { return regeneratorRuntime.wrap(function gen$(_context) { while (1) { switch ((_context.prev = _context.next)) { case 0: _context.next = 2; return 2; case 2: _context.next = 4; return arg; case 4: case \"end\": return _context.stop(); } } });}var b = gen(3);for (var c of b) { console.log(c); // 结果为：2，3} 自动执行基于 thunk1234567891011121314151617function run(gen) { var g = gen(); function next(data) { var result = g.next(data); if (result.done) return result.value; result.value(next); } next();}function* g() { // ...}run(g); 基于 promise12345678910111213141516171819function run(gen) { var g = gen(); function next(data) { var result = g.next(data); if (result.done) return result.value; result.value.then(function(data) { next(data); }); } next();}function* g() { // ...}run(g); async await就是 Generator 函数的语法糖。 优势 内置执行器。像普通函数一样，一行一行的执行，不必像 generator 函数需要调用 next 函数一步一步执行。 更好的语义。async 替换*，await 替换 yield 更广的适用性：await 之后可以跟 promise、原始类型 返回值是 promise 注意 放在 try catch 中 不是继发关系最好同时执行 async 函数可以保留运行堆栈 原理将 Generator 函数和自动执行器，包装在一个函数里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445async function fn(args) { // ...}// 等同于function fn(args) { return spawn(function*() { // ... });}function spawn(genF) { return new Promise(function(resolve, reject) { const gen = genF(); function step(nextF) { let next; try { next = nextF(); } catch (e) { return reject(e); } if (next.done) { return resolve(next.value); } Promise.resolve(next.value).then( function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); } ); } // 传名调用而非传值调用 step(function() { return gen.next(undefined); }); });}","link":"/2019/09/15/2019/09/深入基础-js篇-异步/"},{"title":"深入基础-js篇-浏览器","text":"dom事件有三个阶段，两个方法，两种监听方式。 跨域的解决方案：后端配置，jsonp，iframe，nginx，webpack 数据持久化：cookie、localstorage、sessionStorage、indexDB、service worker 渲染机制：重回、回流 事件三阶段事件捕获处于目标事件冒泡方法preventDefaultstopPropagationaddEventListener第三个参数为 false 时表示在冒泡阶段处理事件，为 true 时表示在捕获时处理事件 跨域跨域解决的例子 Access-Control-Allow-Origin12345678910111213141516171819202122232425262728293031323334var http = require(\"http\");var server = http.createServer();var qs = require(\"querystring\");server.on(\"request\", function(req, res) { var postData = \"\"; // 数据块接收中 req.addListener(\"data\", function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener(\"end\", function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { \"Access-Control-Allow-Credentials\": \"true\", // 后端允许发送Cookie \"Access-Control-Allow-Origin\": \"http://www.domain1.com\", // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ \"Set-Cookie\": \"l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\" // HttpOnly的作用是让js无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); });});server.listen(\"8080\");console.log(\"Server is running at port 8080...\"); koa2 cors12345678910111213141516const cors = require('koa2-cors');// 具体参数我们在后面进行解释app.use(cors({ origin: function (ctx) { if (ctx.url === '/test') { return \"*\"; // 允许来自所有域名请求 } return 'http://localhost:8080'; / 这样就能只允许 http://localhost:8080 这个域名的请求了 }, exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'], maxAge: 5, credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'],})) webpack devServerwebpack 配置解决跨域问题 1234567891011121314module.exports = { devServer: { proxy: { \"/api\": { target: \"&lt;url&gt;\", ws: true, changeOrigin: true }, \"/foo\": { target: \"&lt;other_url&gt;\" } } }}; jsonp利用 script 不受跨域影响的漏洞。但只能解决 get 请求。 客户端 定义获取数据后调用的回调函数。 动态生成对服务端 JS 进行引用的代码。 设置 url 为提供 jsonp 服务的 url 地址，并在该 url 中设置相关 callback 参数。 创建 script 标签，并设置其 src 属性。 把 script 标签加入 head，此时调用开始。 服务端将客户端发送的 callback 参数作为函数名来包裹住 JSON 数据，返回数据至客户端。 12345678910function jsonp(url, callbackName, callback) { let script = document.createElement(\"script\"); script.src = url; script.type = \"text/javascript\"; script.async = true; window[callbackName] = callback; document.body.appendChild(script);} iframepostMessagea.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---&gt; ' + e.data); }, false);&lt;/script&gt; b.html：(http://www.domain2.com/b.html) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain1 ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false);&lt;/script&gt; document.domain只适用于主域相同，子域不同的情况 父窗口：(http://www.domain.com/a.html) 123456&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;;&lt;/script&gt; 子窗口：(http://child.domain.com/b.html) 123456&lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);&lt;/script&gt; window.name a.html：(http://www.domain1.com/a.html) 1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(&apos;iframe&apos;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); }};// 请求跨域b页面数据proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){ alert(data);}); proxy.html：(http://www.domain1.com/proxy….中间代理页，与 a.html 同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) 123&lt;script&gt; window.name = &apos;This is domain2 data!&apos;;&lt;/script&gt; location.hasha.html：(http://www.domain1.com/a.html) 1234567891011121314&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + &apos;#user=admin&apos;; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert(&apos;data from c.html ---&gt; &apos; + res); }&lt;/script&gt; b.html：(http://www.domain2.com/b.html) 123456789&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; };&lt;/script&gt; c.html：(http://www.domain1.com/c.html) 1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;)); };&lt;/script&gt; nginxadd_header123location / { add_header Access-Control-Allow-Origin *;} 反向代理前端访问 domain1，nginx 帮我们访问了 domain2 123456789101112131415#proxy服务器server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; }} 数据持久化 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，发送到用户浏览器并保存在本地的一小块数据，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 cookie服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 localStoragesessionStorageindexDBservice worker渲染机制 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 重绘回流","link":"/2019/09/15/2019/09/深入基础-浏览器/"},{"title":"es6学习","text":"内容来自于对ECMAScript 6 入门的学习总结 let 和 const 命令let只在 let 命令所在的代码块内有效，不存在变量提升，暂时性死区，不存在变量提升。 const一旦声明，常量的值就不能改变。并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。 块级作用域 允许在块级作用域内声明函数。 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 es6 六种声明变量的方式var、function、let、const、import、class。 顶层对象（window、global）的属性var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。 global 对象变量的解构赋值数组的解构赋值1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 对象的解构赋值默认值生效的条件是，对象的属性值严格等于 undefined。 12345678910111213let { foo, bar } = { foo: \"aaa\", bar: \"bbb\" };foo // \"aaa\"bar // \"bbb\"// 下面foo用于匹配，baz是变量声明let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // \"aaa\"let x;{x} = {x: 1};// SyntaxError: syntax error (将{x}理解成代码块了)({x} = {x: 1});x // 1 字符串的解构赋值1const [a, b, c, d, e] = \"hello\"; 数值和布尔值的解构赋值12345let { toString: s } = 123;s === Number.prototype.toString; // truelet { toString: s } = true;s === Boolean.prototype.toString; // true 函数参数的解构赋值12345function add([x, y]) { return x + y;}add([1, 2]); // 3 圆括号问题用途 交换变量的值 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 结构 输入模块的指定方法 字符串的扩展4 个字节的字符的处理为了处理处理 4 个字节的字符而诞生的方法 字符的 Unicode 表示法 codePointAt() String.fromCodePoint() 字符串的遍历器接口 at() normalize() 是否包含确定一个字符串是否包含在另一个字符串中：includes(), startsWith(), endsWith() 重复将原字符串重复 n 次：repeat(n) 补全padStart()，padEnd() matchAll返回一个正则表达式在当前字符串的所有匹配：matchAll() 模板字符串模板字符串的限制：模板字符串默认会将字符串转义，导致无法嵌入其他语言。对于简单字符串，使用反引号会稍慢一点。 raw返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串：String.raw() 正则表达式的扩展数值的扩展二进制和八进制表示法从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀 0 表示，ES6 进一步明确，要使用前缀 0o 表示。 Number.isFinite(), Number.isNaN()它们与传统的全局方法 isFinite()和 isNaN()的区别在于，传统方法先调用 Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回 false, Number.isNaN()只有对于 NaN 才返回 true，非 NaN 一律返回 false。 Number.parseInt(), Number.parseFloat()ES6 将全局方法 parseInt()和 parseFloat()，移植到 Number 对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.isInteger()判断一个数值是否为整数 Number.EPSILON极小的常量 Number.EPSILON。Number.EPSILON === Math.pow(2, -52) 误差范围设为 2 的-50 次方（即 Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 123456function withinErrorMargin(left, right) { return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);}0.1 + 0.2 === 0.3; // falsewithinErrorMargin(0.1 + 0.2, 0.3); // true 安全整数和 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53 到 2^53 之间（不含两个端点），超过这个范围，无法精确表示这个值。Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1;// trueNumber.MAX_SAFE_INTEGER === 9007199254740991;// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER;// trueNumber.MIN_SAFE_INTEGER === -9007199254740991;// true 不要只验证运算结果，而要同时验证参与运算的每个值。 Math 对象的扩展 Math.trunc 去除小数部分 Math.sign 正数+1，负数-1，零 0，负零-0，其他值 NaN。 Math.cbrt 立方根 Math.clz32 JavaScript 的整数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。 Math.imul 返回两个数以 32 位带符号整数形式相乘的结果。 Math.fround 返回一个数的 32 位单精度浮点数形式 Math.hypot 返回所有参数的平方和的平方根。 Math.expm1 返回 ex - 1，即 Math.exp(x) - 1。 Math.log1p 返回 1 + x 的自然对数，即 Math.log(1 + x)。 Math.log10 返回以 10 为底的 x 的对数 Math.log2 返回以 2 为底的 x 的对数 ES6 新增了 6 个双曲函数方法 指数运算符指数运算符（**）。 2 ** 3 === 8 函数的扩展函数参数的默认值 定义了默认值的参数，应该是函数的尾参数。 默认值的两种情况 123456789// 写法一: 给结构赋默认值function m1({ x = 0, y = 0 } = {}) { return [x, y];}// 写法二： 给函数参数赋默认值function m2({ x, y } = { x: 0, y: 0 }) { return [x, y];} 函数的 length 属性，将返回没有指定默认值的参数个数 rest 参数用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 严格模式规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 name 属性123456789101112131415var f = function() {};// ES5f.name; // \"\"// ES6f.name; // \"f\"const bar = function baz() {};// ES5bar.name; // \"baz\"// ES6bar.name; // \"baz\" 箭头函数12345var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) { return num1 + num2;}; 代码块部分多于一条语句时需要加大括号。直接返回一个对象时需要加小括号。箭头函数有几个使用注意点 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 双冒号运算符函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即 this 对象），绑定到右边的函数上面。 1234567foo::bar;// 等同于bar.bind(foo);var method = obj::obj.foo;// 等同于var method = ::obj.foo; 尾调用优化尾调用就是指某个函数的最后一步是调用另一个函数。ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 123456789101112131415function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3); 上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x)的调用帧，只保留 g(3)的调用帧。这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5); // 120 上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1); // 120 完美版 123456function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5); // 120 不支持该功能的环境中如何做？尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 函数参数的尾逗号允许定义和调用时，尾部直接有一个逗号。 数组的扩展扩展运算符…是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列 123456Math.max(...[14, 3, 77]);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 应用场景： 复制数组 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组 1234// 产生新的数组[...arr1, ...arr2, ...arr3];// arr1就是合并后的结果arr1.push(...arr2); 与解构赋值结合 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first; // 1rest; // [2, 3, 4, 5]const [first, ...rest] = [];first; // undefinedrest; // []const [first, ...rest] = [\"foo\"];first; // \"foo\"rest; // [] 字符串 12[...\"hello\"];// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 实现了 Iterator 接口的对象 12let nodeList = document.querySelectorAll(\"div\");let array = [...nodeList]; Map 和 Set 结构，Generator 函数 Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。任何有 length 属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符就无法转换。 Array.of()Array.of 方法用于将一组值，转换为数组。 1234567Array.of(3, 11, 8); // [3,11,8]Array.of(3); // [3]Array.of(3).length; // 1Array(); // []Array(3); // [, , ,]Array(3, 11, 8); // [3, 11, 8] 数组实例的 copyWithin()数组实例的 copyWithin 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。它接受三个参数:target（必需）：从该位置开始替换数据。如果为负值，表示倒数。start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 123// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()indexOf 方法无法识别数组的 NaN 成员 1234567[1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9;}) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9;}) // 2 数组实例的 fill()fill 方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 数组实例的 entries()，keys() 和 values()keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历 1234567891011121314151617181920212223for (let index of ['a', 'b'].keys()) { console.log(index);}// 0// 1for (let elem of ['a', 'b'].values()) { console.log(elem);}// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem);}// 0 \"a\"// 1 \"b\"let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。indexOf 不够语义化，不能判断 NaN 数组的空位1Array(3) // [, , ,] 空位不是 undefined，一个位置的值等于 undefined，依然是有值的。空位是没有任何值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位（所以避免数组的空位）:forEach(), filter(), reduce(), every() 和 some()都会跳过空位。map()会跳过空位，但会保留这个值join()和 toString()会将空位视为 undefined，而 undefined 和 null 会被处理成空字符串。 ES6 则是明确将空位转为 undefined。 对象的扩展属性的简洁表示法对象的普通属性和方法属性都可以简写 12345678910111213141516171819let birth = '2000/01/01';const Person = { name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log('我的名字是', this.name); }};// 对象的方法使用了取值函数（getter）和存值函数（setter）对应的简写const obj = { get foo() {}, set foo(x) {}}; 属性名表达式ES6 允许字面量定义对象时，把表达式放在方括号内作为对象的属性名。 123456789let propKey = 'foo';let obj = { [propKey]: true, ['a' + 'bc']: 123, ['h' + 'ello']() { return 'hi'; }}; 方法的 name 属性方法的 name 属性返回函数名（即方法名）。如果设置了对象的 getter、setter，返回值是方法名前加上 get 和 set；bind 方法创造的函数，name 属性返回 bound 加上原函数的名字；Function 构造函数创造的函数，name 属性返回 anonymous；如果对象的方法是一个 Symbol 值，那么 name 属性返回的是这个 Symbol 值的描述。 Object.is()Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0 不等于-0，二是 NaN 等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true Object.assign()Object.assign 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target = { a: 1 };const source1 = { b: 2 };const source2 = { c: 3 };Object.assign(target, source1, source2);target // {a:1, b:2, c:3} 注意：浅拷贝；同名属性的替换；数组按对象处理；如果要复制的值是一个取值函数，那么将求值后再复制； 属性的可枚举性有四个操作会忽略 enumerable 为 false 的属性：for…in 循环：只遍历对象自身的和继承的可枚举的属性。Object.keys()：返回对象自身的所有可枚举的属性的键名。JSON.stringify()：只串行化对象自身的可枚举的属性。Object.assign()： 忽略 enumerable 为 false 的属性，只拷贝对象自身的可枚举的属性。 对象原型的 toString 方法，以及数组的 length 属性，就通过“可枚举性”，从而避免被 for…in 遍历到。 对象遍历 for…in：循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Object.getOwnPropertyNames：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 Object.getOwnPropertySymbols：返回一个数组，包含对象自身的所有 Symbol 属性的键名。 Reflect.ownKeys(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则：首先遍历所有数值键，按照数值升序排列。其次遍历所有字符串键，按照加入时间升序排列。最后遍历所有 Symbol 键，按照加入时间升序排列。 Object.getOwnPropertyDescriptors()返回指定对象所有自身属性（非继承属性）的描述对象。 proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()proto属性（前后各两个下划线），用来读取或设置当前对象的 prototype 对象。无论从语义的角度，还是从兼容性的角度，都不要使用这个proto属性，而是使用 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 super 关键字指向当前对象的原型对象。super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 Object.keys()，Object.values()，Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的数组。 1234567891011121314let {keys, values, entries} = Object;let obj = { a: 1, b: 2, c: 3 };for (let key of keys(obj)) { console.log(key); // 'a', 'b', 'c'}for (let value of values(obj)) { console.log(value); // 1, 2, 3}for (let [key, value] of entries(obj)) { console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]} 对象的扩展运算符对象的解构赋值用于从一个对象取值，相当于将目标对象自身(不包含继承的)的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。 Symbol概述一种新的原始数据类型 Symbol，表示独一无二的值。 作为属性名的 Symbol能防止某一个键被不小心改写或覆盖。 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。 123456789101112131415const shapeType = { triangle: Symbol()};function getArea(shape, options) { let area = 0; switch (shape) { case shapeType.triangle: area = .5 * options.width * options.height; break; } return area;}getArea(shapeType.triangle, { width: 100, height: 100 }); 属性名的遍历Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 Symbol.for()，Symbol.keyFor()Symbol.for 方法使用同一个 Symbol 值，生成同一个值。Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。 实例：模块的 Singleton 模式123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() { this.foo = 'hello';}if (!global[FOO_KEY]) { global[FOO_KEY] = new A();}module.exports = global[FOO_KEY]; 上面代码中，可以保证 global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。如果需要修改，可以通过 Symbol.for 来修改。 内置的 Symbol 值 Symbol.hasInstance对象的 Symbol.hasInstance 属性，指向一个内部方法。当其他对象使用 instanceof 运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo 在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 1234567class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; }}[1, 2, 3] instanceof new MyClass() // true Symbol.isConcatSpreadable对象的 Symbol.isConcatSpreadable 属性等于一个布尔值，表示该对象用于 Array.prototype.concat()时，是否可以展开。 1234567let arr1 = ['c', 'd'];['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']arr1[Symbol.isConcatSpreadable] // undefinedlet arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] Symbol.speciesSymbol.species 的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。 Symbol.match,Symbol.replace,Symbol.search,Symbol.split对象的属性，指向一个函数。当执行 str.match(myObject)/str.replace(myObject)/str.search(myObject)/str.split(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 Symbol.iterator对象的 Symbol.iterator 属性，指向该对象的默认遍历器方法。 Symbol.toPrimitive对象的 Symbol.toPrimitive 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toStringTag对象的 Symbol.toStringTag 属性，指向一个方法。在该对象上面调用 Object.prototype.toString 方法时，如果这个属性存在，它的返回值会出现在 toString 方法返回的字符串之中，表示对象的类型。 Symbol.unscopables对象的 Symbol.unscopables 属性，指向一个对象。该对象指定了使用 with 关键字时，哪些属性会被 with 环境排除。 Set 和 Map 数据结构Set它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身。四种操作方法： add(value)：添加某个值，返回 Set 结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为 Set 的成员。 clear()：清除所有成员，没有返回值。四种遍历方法：（按照插入顺序遍历） keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 WeakSetWeakSet 的成员只能是对象，而不能是其他类型的值。不存在 size，不能遍历。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 Map它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 size,set(),keys(),has(),delete(),clear()keys()，values()，entries()，forEach() map 与 array,object,json 之间的相互转换 WeakMapWeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。WeakMap 的键名所指向的对象，不计入垃圾回收机制。get()、set()、has()、delete() Proxy代理器。在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 基本使用12345678910var obj = new Proxy({}, { get: function (target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { console.log(`setting ${key}!`); return Reflect.set(target, key, value, receiver); }}); Proxy 实例的方法 get(target, propKey, receiver)：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。defineProperty(target, propKey, propDesc)：拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。preventExtensions(target)：拦截 Object.preventExtensions(proxy)，返回一个布尔值。getPrototypeOf(target)：拦截 Object.getPrototypeOf(proxy)，返回一个对象。isExtensible(target)：拦截 Object.isExtensible(proxy)，返回一个布尔值。setPrototypeOf(target, proto)：拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 Proxy.revocable()取消 Proxy 实例。 12345678910let target = {};let handler = {};let {proxy, revoke} = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked this 问题在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。 实例：Web 服务的客户端Reflect介绍 将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。 修改某些 Object 方法的返回结果，让其变得更合理。 让 Object 操作都变成函数行为。 让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 静态方法Reflect.apply(target, thisArg, args)Reflect.construct(target, args)Reflect.get(target, name, receiver)Reflect.set(target, name, value, receiver)Reflect.defineProperty(target, name, desc)Reflect.deleteProperty(target, name)Reflect.has(target, name)Reflect.ownKeys(target)Reflect.isExtensible(target)Reflect.preventExtensions(target)Reflect.getOwnPropertyDescriptor(target, name)Reflect.getPrototypeOf(target)Reflect.setPrototypeOf(target, prototype) 实例：使用 Proxy 实现观察者模式123456789101112131415161718192021222324const person = observable({ name: '张三', age: 20});function print() { console.log(`${person.name}, ${person.age}`)}observe(print);person.name = '李四';// 输出// 李四, 20const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, {set});function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;} Promise 对象推荐阅读 透彻掌握 Promise 的使用，读这篇就够了 Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理和更强大。回调地狱。数据请求与数据处理明确的区分开来。所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 基本用法1234567891011121314151617181920212223242526272829const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); }); return promise;};getJSON(\"/posts.json\").then(function(json) { console.log('Contents: ' + json);}, function(error) { console.error('出错了', error);}); then()和 catch()12345678910111213141516// badpromise .then(function(data) { // success }, function(err) { // error });// goodpromise .then(function(data) { //cb // success }) .catch(function(err) { // error }); Promise.prototype.finally()finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 Promise.all()将多个 Promise 实例，包装成一个新的 Promise 实例。只要 p1、p2、p3 之中全部 fulfilled，p 的状态 fulfilled；之中有一个 rejected，p 的状态就 rejected。如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法。 Promise.race()将多个 Promise 实例，包装成一个新的 Promise 实例。只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。 Promise.resolve()Promise.reject()应用Promise.try()","link":"/2018/05/09/2018/05/es6学习/"},{"title":"”小红书“读书笔记","text":"js 学习中有些东西，当时看过，过后就忘了，这里还是总结一下，没事就拿出来翻一翻。 call apply bind 的使用当然，由于 es6 的出现，下面的方法可能会显得笨拙。 合并数组 12Array.prototype.push.apply(array1, array2);c = [...a, ...b]; 数组中找到最大值 123maxInNumbers = Math.max.apply(Math, numbers);maxInNumbers = Math.max.call(Math, 5, 458, 120, -215);Math.max(...[14, 3, 77]); 验证数据类型如何检查 JavaScript 变量类型？ 1Object.prototype.toString.call(obj) === \"[object Array]\"; 伪数组转数组（dom 元素，方法的 arguments） 123Array.prototype.slice.call(document.getElementsByTagName(\"*\"));Array.prototype.slice.call(arguments);Array.from(arguments); 判断两个对象是否相等Javascript 判断对象是否相等 一个例子，打印日志的方法 123456function log() { var args = Array.prototype.slice.call(arguments); args.unshift(\"(app)\"); console.log.apply(console, args);} 数组方法 instanceof push、pop shift、unshift toString、valueOf reverse、sort concat、slice、splice indexOf、lastIndexOf every、filter、forEach、map、some reduce、reduceRight 正则表达式 字面量形式创建、RegExp构造函数创建 g全局匹配、i忽略大小写、m多行匹配 exec、test方法 String 方法 chaAt charCodeAt concat slice substr substring indexOf lastIndexOf trim toLowerCase toUpperCase match search replace split localeCompare fromCharCode Math 方法 min max ceil floor round random abs exp log pow sqrt cos sin tan acos asin atan 对象 property defineProperty prototype __proto__ constructor 原型 原型链 instanceof 工厂模式弊端：无法解决对象识别问题（怎样知道一个对象的类型） 123456789101112function createPerson(name, age, job) { var o = {}; o.name = name; o.age = age; o.job = job; o.sayName = function() { alert(this.name); }; return o;}var person1 = createPerson(\"xixi\", 29, \"工程师\");var person2 = createPerson(\"lili\", 29, \"搬砖\"); 构造函数模式优点：不用显式创建对象，属性赋值给 this 对象，没有 return 语句。constructor 指向 Person弊端：每个方法要在每个实例上重新创建（sayName 方法） 12345678910function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name); };}var person1 = new Person(\"xixi\", 29, \"工程师\");var person2 = new Person(\"lili\", 29, \"搬砖\"); 原型模式优点：解决了上边两个的问题弊端：省略了参数初始化，导致所有实例默认情况下取值相同。其共享性，对于包含引用类型值的属性来说，问题就比较突出了。 1234567891011121314151617181920function Person(){}Person.prototype = { constructor:Person, name:\"xixi\", age: 29, job: '搬砖'， friends: ['haha','hehe'], sayName: function(){ alert(this.name) }}var person1 = new Person()var person2 = new Person()person1.friends.push('lele')alert(person1.friends) //'haha,hehe,lele'alert(person2.friends) //'haha,hehe,lele'alert(person1.friends===person2.friends) //true 组合使用构造函数和原型对象模式构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。 123456789101112131415161718192021222324252627282930function Person(name,age,job){ this.name = name this.age = age this.job = job this.friends = ['haha','hehe']}Person.prototype = { sayName: function(){ alert(this.name) }}var person1 = new Person('lili',20,'搬砖')var person2 = new Person('lvlv'，21，'搬石头')person1.friends.push('lele')alert(person1.friends) //'haha,hehe,lele'alert(person2.friends) //'haha,hehe,lele'alert(person1.friends===person2.friends) //falsealert(person1.sayName===person2.sayName) //truealert(Person.prototype.isPrototypeOf(person1)) //truealert(person1.hasOwnProperty(\"name\")) //falsealert(\"name\" in person1) //truealert(Object.keys(person1)) //\"name,age,job,friends,sayName\"//对原型对象所做的任何修改，立即从实例上反应出来var friend = new Person()Person.prototype.sayHi = function(){ alert('Hi')}friend.sayHi() //'Hi' 寄生构造函数模式12345678910function SpecialArray() { var values = []; values.push.apply(values, arguments); values.toPipedString = function() { return this.join(\"|\"); }; return values;}var colors = new SpecialArray(\"red\", \"blue\", \"green\");alert(colors.toPipedString()); // \"red|blue|green\" 继承原型链让一个类型的原型对象等于另一个类型的实例。问题：包含引用类型值的原型，这个引用类型会被共享。不能向超类型（superType）的构造函数中传递参数。 123456789101112131415161718192021function SuperType() { this.property = true;}SuperType.prototype.getSuperType = function() { return this.property;};function SubType() { this.subProperty = false;}//继承了superTypeSubType.prototype = new SuperType();SubType.prototype.getSubType = function() { return this.subProperty;};var instance = new SubType();alert(instance.getSuperType()); // true 借用构造函数为解决上边的问题，我们借助构造函数。问题：函数不能复用。超类型的原型中定义的方法，对于子类型是不可见的。 123456789101112131415161718function SuperType(name) { this.name = name; this.colors = [\"red\", \"blue\", \"yellow\"];}function SubType(name) { //继承了SuperType SuperType.call(this, name);}var instance1 = new SubType(\"lili\");instance1.color.push(\"black\");alert(instance1.name); // lilialert(instance1.colors); //\"red,blue,yellow,black\"var instance2 = new SubType(\"haha\");alert(instance2.name); // hahaalert(instance2.colors); //\"red,blue,yellow\" 组合继承利用原型链对原型属性和方法进行继承，通过构造函数对实例属性进行继承。第一次调用 SuperType 时，SubType.prototype 中有 color 属性，并且是共享的。第二次调用 SuperType 时，SubType 本身有 color 属性，覆盖了 SubType.prototype 中的 color 属性，并且 SubType 本身有 color 属性在实例之后是独立的。 123456789101112131415161718192021222324252627282930function SuperType(name) { this.name = name; this.color = [\"red\", \"blue\", \"yellow\"];}SuperType.prototype.sayName = function() { alert(this.name);};function SubType(name, age) { SuperType.call(this, name); //第二次调用SuperType this.age = age;}SubType.prototype = new SuperType(); //第一次调用SuperTypeSubType.prototype.constructor = SubType;SubType.prototype.sayAge = function() { alert(this.age);};var instance1 = new SubType(\"lili\", 25);instance1.color.push(\"black\");alert(instance1.color); //\"red,blue,yellow,black\"instance1.sayName(); //\"lili\"instance1.sayAge(); //25var instance2 = new SubType(\"hehe\", 20);alert(instance2.color); //\"red,blue,yellow\"instance2.sayName(); //\"hehe\"instance2.sayAge(); //20 原型式继承问题：引用类型值的属性共享 1234567891011121314151617181920function object(o) { function F() {} F.prototype = o; return new F();}var person = { name: \"hehe\", friends: [\"lili\", \"haha\"]};var anotherPerson = object(person);anotherPerson.name = \"pipi\";anotherPerson.friends.push(\"papa\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"kiki\";yetAnotherPerson.friends.push(\"nini\");alert(person.friends); //\"lili,haha,papa,nini\" 寄生式继承12345678910111213141516171819202122function object(o){ function F (){ } F.prototype = o return new F()}function createAnother(original){ var clone = object(original) clone.sayHi = function() { alert('Hi) } return clone}var person = { name: 'lili', friends: [\"mimi\",\"titi\"]}var anotherPerson = createAnother(person)anotherPerson.sayHi() //Hi 寄生组合式继承为解决组合式继承会调用两次超类型构造函数的问题，所以诞生了寄生组合式继承。所谓寄生组合式继承，就是通过构造函数来继承属性，通过原型链的混成形式来继承方法。 只调用一次 SuperType,避免因此在 SubType 上面创建不必要的、多余的属性。 原型链保持不变，所以可以正常使用 incetanceof 和 isPrototypeOf。 12345678910111213141516171819202122232425262728293031function object(o) { function F() {} F.prototype = o; return new F();}function inheritPrototype(subType, superType) { var prototype = object(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;}function SuperType(name) { this.name = name; this.colors = [\"red\", \"yellow\", \"blue\"];}SuperType.prototype.sayName = function() { alert(this.name);};function SubType(name, age) { SuperType.call(this, name); this.age = age;}inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function() { alert(this.age);}; 函数函数声明与函数表达式函数声明提升 12345678a(); //1var a = function() { alert(2);};function a() { alert(1);}a(); //2 闭包 有权访问另一个函数作用域中变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 创建函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[scope]]属性中。作用域链本质是一个指向变量对象的指针列表，他只引用，但不实际包含变量对象。 调用函数时，会创建一个执行环境，然后通过复制函数的[[scope]]属性中的对象，构建起执行环境的作用域链。 此后，又一个活动对象（如本地活动对象）被创建，并推入执行环境作用域链的前端。 按理说函数执行完毕之后，局部活动对象就会被销毁，内存中仅保留全局作用域，但闭包例外。createComparisonFunction 函数返回之后，其执行环境作用域链销毁，但活动对象仍留在内存中，直到匿名函数被销毁。 1234567891011121314151617181920function createComparisonFunction(propertyName) { return function(value1, value2) { var value1 = object1[propertyName]; var value2 = object2[propertyName]; if (value1 &lt; value2) { return -1; } else if (value1 &gt; value2) { return 1; } else { return 0; } };}// 创建函数var compare = createComparisonFunction(\"name\");// 调用函数var result = compare({ name: \"lili\" }, { name: \"haha\" });// 销毁函数（释放内存）compare = null; 闭包与变量下面这段代码，的每个函数都返回 10。因为每个函数的作用域链中，都保存着 createComparisonFunction()函数的活动对象，所以他们都引用了同一个 i。解决办法就是把 i 传递给匿名函数，或者声明 i 时把 var 换成 let。 12345678910111213141516171819function createFunction1() { var result = []; for (var i = 0; i &lt; 10; i++) { result[i] = function() { return i; }; } return result;}function createFunction2() { var result = []; for (var i = 0; i &lt; 10; i++) { result[i] = function(i) { return i; }; } return result;} 作用域作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到 window 对象即被终止，作用域链向下访问变量是不被允许的。 参数arguments类数组对象。 thisMDN 中对 this 的总结this 全局作用域无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。 函数作用域在函数内部，this 的值取决于函数被调用的方式。 简单调用：最普通的调用，严格模式下，通过 apply|call 调用 bind 箭头函数 作为对象的方法调用：作为对象方法调用，原型链中的 this，getter、setter 中的 this 作为构造函数中的 this 作为一个 dom 事件处理函数 作为一个内联事件处理函数 模仿块级作用域（私有作用域）1(function() {})(); 变量 多次声明同一个变量，后续声明被忽略，不过会执行后续声明的变量的初始化。初始化未经声明的变量，总是会创建一个全局变量。 私有变量 函数参数。 局部变量。 函数内部定义的其他函数。 模块模式单例：只有一个实例对象特权方法：有权访问私有变量、私有函数的公有方法称为特权方法。模块模式：为单例创建私有变量、特权方法。 12345678910111213var application = function() { var components = []; components.push(new BaseComponents()); return { getComponentCount: function() {}, registerComponent: function(component) { if (typeof component === \"object\") { components.push(component); } } };}; DOMNode 类型Dom 中所有节点类型实现,javascript 中所有节点类型都继承自 Node 类型nodeName nodeValuechildNodes NodeList(类数组对象)parentNode previousSibling nextSiblingfirstChild lastChildhasChildNodes() ownerDocument()appendChild() 如果传入的节点已经是文档的一部分，那么节点将从原来的位置移动到新的位置。使用 cloneNode()解决这个问题。insertBefore() replaceChild() removeChild() cloneNode()normallize() 删除空文本节点，合并相邻文本节点 Document通过 Document 表示文档在浏览器中 document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 html 页面。document 对象是 window 对象的一个属性，因此可以全局访问。 Document 类型nodeType：9，nodeName：”#document”，nodeValue、parentNode、ownerDocument 都是 null。其子节点可能是一个 DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction、comment。 文档字子节点document.documentElement、document.firstChild、document.childNodes[0]都指向&lt;html&gt;元素。document.body 指向&lt;body&gt;元素。document.doctype 指向&lt;!DOCTYPE&gt;,兼容问题所以用处有限。 文档信息document.title 可获取修改document.URL。document.domain 只包含页面域名。不能将这个属性设置为 URL 中不包含的域。修改后改不回。referrer 链接到当前页面的那个页面的 URL。 查找元素getElementById(),getElementsByTagName()namedItem():document.getElementsByTagName(‘img’).namedItem(‘myImage’)document.getElementsByTagName(‘img’)[‘myImage’]对数值索引就会调用 item(),对字符串索引就会调用 namedItem() anchors:所有带 name 特性的&lt;a&gt;links:文档中所有包含 href 特性的&lt;a&gt;forms: 文档中所有的&lt;form&gt;images:文档中所有的&lt;img&gt; 文档写入：write()、writeln()、open()、close()。write()、writeln()可以动态包含外部资源。ElementtagName 和 nodeName 都会输出标签名。HTML 标签名始终以全部大写表示，XML 会与源代码保持一致。所有 HTML 元素都由 HTMLElement 类型表示，HTMLElement 直接继承自 Element。 操作特性getAttribute()、setAttribute()、removeAttribute()公认特性可以用属性的方式访问或者设置，公认特性推荐使用属性方式通过 getAttribute()获取的 style，得到的是文本，通过属性访问得到的是对象。 12345&lt;div id=\"myDiv\" dataParam=\"myData\"&gt;&lt;/div&gt;;let div = document.getElementById(\"myDiv\");console.log(div.id); //myDivconsole.log(div.dataParam); //undefined(IE会返回正确的值) attributes 属性12345let div = document.getElementById(\"myDiv\");console.log(div.attributes.getNamedItem(\"class\").nodeValue); //\"myClass\"console.log(div.attributes[\"class\"].nodeValue); //\"myClass\"div.attributes.removeNamedItem(\"class\");div.attributes.setNamedItem(\"class\"); specified 属性用来确认是否指定了相应的属性。 创建元素document.createElement() childNodes在 ie 中，ul 中有三个子节点，而在其他浏览器中是 7 个子节点（多了四个文本节点），当把空白节点删除之后，就都是三个节点了。 12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; Text 类型createTextNode()、normalize()、splitText() 其他类型 Comment：注释在 DOM 中通过 Comment 类型来表示。 CDATASection：只针对 XML 文档中 CDATA 区域。 DocumentType：doctype 相关信息，仅部分浏览器支持。 DocumentFragment：‘轻量级’文档，不会像完整文档那样占用额外的资源。它可以作为一个‘仓库’使用，保存着将来可能添加到文档中的节点。 123456789var fragment = document.createDocumentFragment();var ul = document.getElementById(\"myList\");var li = null;for (var i = 0; i &lt; 10; i++) { li = document.createdElement(\"li\"); li.appendChild(document.createTextNode(\"Item\" + i)); fragment.appendChild(li);}ul.appendChild(fragment); Attr 类型元素的特性在 DOM 中以 Attr 类型来表示。Attr 对象的属性 name，value，specified（区别特性是在代码中指定的还是默认的）。推荐使用 getAttribute()、setAttribute()、removeAttribute() 123var attr = document.createdAttribute(\"align\");attr.value = \"left\";element.setAttributeNode(attr); 动态脚本外部文件形式123456function loadScript(url) { var script = document.createElement(\"script\"); script.type = \"text/javascript\"; script.src = url; document.body.appendChild(script);} 行内方式12345678910function loadScript(js) { var script = document.createElement(\"script\"); script.type = \"text/javascript\"; var code = js; try { script.appendChild(document.createTextNode(code)); } catch (ex) { script.text = code; }} 动态样式外部文件形式12345678function loadStyle(url) { var link = document.createElement(\"link\"); link.rel = \"stylesheet\"; link.type = \"text/css\"; link.href = url; var head = document.getElementByTagName(\"head\")[0]; head.appendChild(link);} 嵌入式 CSS1234567891011function loadStyle(css) { var style = document.createElement(\"style\"); style.type = \"text/css\"; try { style.appendChild(document.createTextNode(css)); } catch (ex) { style.styleSheet.cssText = css; } var head = document.getElementsByTagName(\"head\")[0]; head.appendChild(style);} 操作表格HTML DOM 为 table、tbody、tr 元素添加了一些属性方法。 透彻理解 DOMNodeList、NamedNodeMap、HTMLCollection他们都是类数组对象，并且他们都是“动态的”，每当文档发生变化时，他们都会更新。 12345678910var divs = document.getElementsByTagName(\"div\");alert(divs instanceof HTMLCollection); //truevar div = document.getElementById(\"div1\");var children = div.childNodes; //获取div元素子节点集合alert(children instanceof NodeList); //truevar attrs = div.attributes; //获取div元素的特性alert(children instanceof NamedNodeMap); //true 操作元素 DOM 选择符 API 以下方法接受一个 css 选择器 querySelector()返回第一个匹配的元素。 querySelectorAll()返回一个 NodeList 实例。能够调用他的包括 Document、DocumentFragment、Element。 matchesSelector()如果调用元素与选择符匹配，则返回 true。 元素遍历。元素间空格，IE9 之前不会返回文本节点，而其他浏览器都会返回，因此诞生一下几个方法，避免这种问题。 childElementCount firstElementChild lastElementChild previouseElementSibling nextElementSibling HTML5 相关 getElementsByClassName(): 返回 nodeList classList属性时 DOMTokenList 的实例，定义了如下方法add(value)添加，如果已存在就不添加了contains(value)是否存在，如果存在就返回 trueremove(value)移除toggle(value)如果存在给定值就删除，否则添加。使用起来是这样的 document.getElementById(‘myDiv’).classList.toggle(‘disabled’) activeElement当前获得了焦点的元素，加载完成时是 body，加载中是 null。 hasFocus确定文档是否获取了焦点。 readyState加载状态 loading，complete。 compatMode页面渲染模式“CSS1Compat”标准模式，“BackCompat”混杂模式。 headhead 元素。 charset文档中实际使用的字符集。deafaultCharset根据浏览器及系统的默认字符集。 dataset自定义属性值（自定义属性要加 data-前缀），是 DOMStringMap 的实例。 1&lt;div id=\"myDiv\" data-param=\"test\"&gt;&lt;/div&gt; 1document.getElementById(\"myDiv\").dataset.param; innerHTML返回调用元素的所有子节点的 HTML 标签 outerHTML返回调用它的元素及该元素的所有子节点的 HTML 标签，写模式下替换掉调用元素。 insertAdjacentHTML接受两个参数：第一个参数是插入的位置（beforeBegin、afterBegin、beforeEnd、afterEnd），第二个参数是插入的内容。 使用 innerHTML、outerHTML、insertAdjacentHTML 时注意事项：手动删除被替换元素的事件处理程序和 javascript 对象属性。避免频繁设置（将插入的内容一次性设置） scrollIntoView()窗口滚动让调用元素顶部与窗口齐平，如果传入 false 则让元素底部与窗口持平。 专有扩展，部分支持：documentMode文档模式children只包含元素子节点，不包含空白文档节点。contains()用来查询节点是不是另一个节点的后代。compareDocumentPositionDOM Level 3 中用来确定节点间的关系。innerText、outerText。滚动：scrollIntoViewIfNeeded、scrollByLines、scrollByPages 事件事件流事件冒泡：事件由最具体的元素接受，然后逐级向上传播。事件捕获：不太具体的节点开始向具体节点传播。DOM 事件流：事件捕获，处于目标阶段，事件冒泡。 事件处理程序HTML 事件处理程序就是通过标签的 onclick 属性来设置。DOM0 级事件处理程序通过 DOM 元素的 onclick 属性来设置。DOM2 级事件处理程序最后一个参数为 false 时表示在冒泡阶段处理，为 true 时表示在捕获阶段处理。移除事件时的事件处理程序必须是同一个。IE8 及更早的版本需要特殊处理。 123456789101112131415161718192021222324252627282930313233343536373839404142var EventUtil = { addEvent:function(element,type,handler){ if(element.addEventListener){ element.addEventListener(type,handler,false) }else if(element.atatchEvent){ element.attachEvent(\"on\"+type,handler) }else{ element[\"on\"+type] = handler } }, removeEvent:function(element,type,handler){ if(element.removeEventListener){ element.removeEventListener(type,handler,false) }else if(element.deatchEvent){ element.detachEvent(\"on\"+type,handler) }else{ element[\"on\"+type] = null } }, getEvent:function(event){ return event?event:window.event }, getTarget:function(event){ return event?event.target:window.srcElement }, // 阻止默认事件 preventDefault:function(event){ if(event.preventDefault){ event.preventDefault() }else{ event.returnValue = null } }, // 阻止事件传播 stopPropagation:function(event){ if(event.stopPropagation){ event.stopPropagation() }else{ event.cancelBubble = true } }} 事件类型 UI 事件：load、unload、abort（用户停止下载过程时）、error（javascript 错误时）、select（选择 input 或 textarea 中的一个或多个字符时）、risize、scroll。 焦点事件：不冒泡的 focus、blur，冒泡的 focusin、focusout。 鼠标事件：click、dblclick、mousedown、mouseup、mouseenter、mouseleave、mouseover、mouseout、mousemove。鼠标事件的 event 对象属性：关于鼠标位置的 clientX、clientY、pageX、pageY、screen X、screenY，关于 shiftKey、ctrlKey、altKey、metaKey，相关元素（例如 mouseover 失去光标的那个元素）信息 relatedTarget，button（0 表示鼠标左键，1 滚轮键，2 鼠标右键），detail（单击了多少次）。 滚轮事件：mousewheel（部分浏览器支持，向前滚动是 120 的倍数）。DOMMouseScroll（火狐支持，向前滚动是-3 的倍数）。 文本事件：适用于可编辑区域：textInput。 键盘事件：适用于任何可获得焦点的元素：keydown（任意键出发，按住不放重复出发）、keypress（字符或 ESC 键触发，按住不放重复触发）、keyup。键盘事件的 event 对象属性：charcode、key、char、inputMethod（输入方式）。 变动事件：DOM 发生变化时触发。 HTML5 事件：contextmenu（菜单事件，通过 preventDefault 组织默认菜单事件）、beforeunload、DomContentLoaded（DOM 结构加载完成）、pageshow、pagehide、hashchange（地址栏 hash 改变） 设备事件： 触摸与手势事件：touchstart、touchmove、touchend、touchcancel。触摸事件包含三个数组：touchs（当前跟踪的触摸操作的 touch 对象数组）、targetTouchs（特定于事件目标的 touch 对象数组）、changeTouchs（上次触摸以来发生了改变的 touch 对象数组） 内存性能每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 javascript 代码之间就会建立一个链接。连接数量量越多页面执行起来就越慢，所以采用一下两种方式解决这种问题： 事件委托：利用事件冒泡，至指定一个事件处理程序。优点：立即具备适当的功能，减少 DOM 引用，内存空间更少提升性能。 移除事件处理程序：当从文档中移除带有事件处理程序的元素时，卸载页面时（部分浏览器会有问题）手动移除事件处理程序。 模拟事件createdEvent()接受一个事件类型字符串包括 UIEvents、MouseEvents、MutationEvents、HTMLEvents（以上字符串实在 DOM 二级中，DOM 三级中去掉了 s，移除了最后一项）。支持事件的 DOM 节点，通过 dispatchEvent()方法触发相应事件。 模拟鼠标事件创建 MouseEvents 事件对象，会返回一个 initMouseEvent()方法，用于指定该鼠标事件有关信息。 1234let div = document.getElementById(\"myDiv\")let event = document.createEvent(\"MouseEvents\")event.initMouseEvent(\"click\",true,true,document.deafaultView)div.dispatchEvent(event) 模拟键盘事件创建 KeyboardEvent 事件对象返回一个 initKeyEvent()方法 模拟其他事件创建 MountationEvents 事件对象返回一个 initMountation()方法。 自定义 DOM 事件（仅部分浏览器支持）。 IE8 及之前版本模拟事件需要特殊处理。 离线应用与客户端存储离线检测navigator.online 为 true 时表示设备能上网，false 表示设备离线。HTML5 定义了两个事件 online 和 offline 用于捕获设备 应用缓存（已废弃）应用缓存 appcache（已废弃），请改用Service Workers代替。从浏览器的缓存中分出一块缓存区。利用描述文件列出下载和缓存的资源，保存在缓存区。applicationCache.status 用于获取应用缓存的当前状态。应用缓存相关事件。 cookieHTTP cookies服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。数量和大小都有限制。浏览器关闭之后它会被自动删除,也可以指定一个特定的过期时间（Expires）或有效期（Max-Age），设定的日期和时间只与客户端相关，而不是服务端。子 cookie。 12345678910111213141516171819202122232425262728293031323334353637var CookieUtil = { get: function (name) { var cookieName = encodeURIComponent(name) + \"=\", cookieStart = document.cookie.indexOf(cookieName), cookieValue = null; if (cookieStart &gt; -1) { var cookieEnd = document.cookie.indexOf(\";\", cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); } return cookieValue; }, set: function (name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) + \"=\" + encodeURIComponent(value); if (expires instanceof Date) { cookieText += \"; expires=\" + expires.toGMTString(); } if (path) { cookieText += \"; path=\" + path; } if (domain) { cookieText += \"; domain=\" + domain; } if (secure) { cookieText += \"; secure\"; } document.cookie = cookieText; }, unset: function (name, path, domain, secure) { this.set(name, \"\", new Date(0), path, domain, secure); }}; Srorage 类型Web Storage API sessionStorage：只有创建页面可访问。该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 globalStorage：跨越会话存储数据。globalStorage[“wrox.com”].name = “Nicholas”。javascript 删除或用户清除浏览器缓存数据。 localStorage：同域（子域无效），同协议，同端口。相当于 globalStorage[location.host]。avascript 删除或用户清除浏览器缓存数据。 IndexedDB浏览器中一种保存结构化数据的数据库，使用对象保存数据。 ajax1234567891011121314151617181920212223242526var xhr = new XMLHttpRequest()xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300 || xhr.status == 304){ alert(xhr.responseText) }else{ alert(\"error code:\"+xhr.status) } }}// get请求var url = 'test.do'function addURLParam(url,key,value){ url += (url.indexOf(\"?\") == -1 ? \"?\":\"&amp;\") url += encodeURIComponent(name)+\"=\"+encodeURIComponent(value) return url}addURLParam(url,\"name\",\"chenjp\")xhr.open('get',url,true)// post请求xhr.open('post','test.do',true)xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\")var form = document.getElementById(\"user-form\")xhr.send(serialize(form)) 跨域问题 jsonp cors 跨域资源共享 后端代理 iframe + location.hash iframe + window.name iframe + postMessage iframe + window.domin 函数高级操作函数节流解释：函数节流，简单地讲，就是让一个函数无法在很短的时间间隔内连续调用，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。原理：当我触发一个时间时，先 setTimout 让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就 clear 掉原来的定时器，再 setTimeout 一个新的定时器延迟一会执行 柯里化部分求值，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。","link":"/2018/02/08/2018/02/小红书读书笔记/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"规范","slug":"规范","link":"/tags/规范/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"组件","slug":"组件","link":"/tags/组件/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"koa","slug":"koa","link":"/tags/koa/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"性能","slug":"性能","link":"/tags/性能/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"es6","slug":"es6","link":"/tags/es6/"}],"categories":[{"name":"阶段总结","slug":"阶段总结","link":"/categories/阶段总结/"},{"name":"深入基础","slug":"深入基础","link":"/categories/深入基础/"},{"name":"项目开发","slug":"阶段总结/项目开发","link":"/categories/阶段总结/项目开发/"},{"name":"基础系列","slug":"基础系列","link":"/categories/基础系列/"},{"name":"规范篇","slug":"深入基础/规范篇","link":"/categories/深入基础/规范篇/"},{"name":"js篇","slug":"基础系列/js篇","link":"/categories/基础系列/js篇/"},{"name":"css篇","slug":"基础系列/css篇","link":"/categories/基础系列/css篇/"},{"name":"nodejs","slug":"基础系列/nodejs","link":"/categories/基础系列/nodejs/"},{"name":"vue篇","slug":"深入基础/vue篇","link":"/categories/深入基础/vue篇/"},{"name":"前端框架篇","slug":"基础系列/前端框架篇","link":"/categories/基础系列/前端框架篇/"},{"name":"js篇","slug":"深入基础/js篇","link":"/categories/深入基础/js篇/"}]}